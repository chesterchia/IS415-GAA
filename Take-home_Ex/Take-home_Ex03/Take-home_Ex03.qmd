---
title: "Take Home Exercise 3"
author: "Chester Chia"
date: "10th March 2024"
---

```{r}
pacman::p_load(tidyverse, sf, tmap, maptools, spatstat, raster, tidyr, readxl, nngeo)
```

## 0.0 Overview

For my team's project we had three planned features:

-   Exploratory Data Analysis
-   Kernel Density Estimation
-   Spatial Clustering

Upon reviewing feedback, we have revised our features to these:

-   Exploratory Data Analysis
-   **Spatial Point Patterns Analysis**
-   Accessibility Modelling

For this take-home exercise, I will be working on the second module, **Spatial Points Patterns Analysis**. This will include generating KDE maps and performing 2nd order SPPA based on variables that are set as inputs by the user.

## 1.0 Data Processing

### 1.1 Importing Singapore Census of Population Data

```{r}
pop2020 <- read_excel("data/aspatial/Singapore Census of Population (2020).xlsx", sheet=2, skip=4, col_names=TRUE)
```

There are many rows where the entire row comprises of NA values. These are irrelevant, so we will remove them first.

```{r}
pop2020 <- pop2020[rowSums(is.na(pop2020)) != ncol(pop2020),]
```

Next, we will do 3 things:

-   Rename "Planning Area of Residence" for clarity
-   Remove rows where any other column **except the first column** is "NA". We do not need any rows with NA values, but the first columns can be NA if they are subzones.
-   Remove rows where the first column is "Planning Area of Residence" - this indicates the start of a new page, and is not data that we can use.

```{r}
colnames(pop2020)[1] = "Planning_Area"
cols_to_check <- names(pop2020)[-1]
pop2020 <- pop2020[complete.cases(pop2020[, cols_to_check]), ]
pop2020 <- pop2020[!(pop2020$Planning_Area %in% "Planning Area of Residence"),]
```

Now to address the rows with the first column as "NA". We need to fill these up with their proper planning areas, which just so happen to be the last non-missing value. We can do this using the following function:

```{r}
fill_missing <- function(x) {
  non_na_index <- which(!is.na(x))
  last_non_na <- NA
  for (i in 1:length(x)) {
    if (is.na(x[i])) {
      if (!is.na(last_non_na)) {
        x[i] <- x[last_non_na]
      }
    } else {
      last_non_na <- i
    }
  }
  return(x)
}

pop2020$Planning_Area <- fill_missing(pop2020$Planning_Area)
```

Subsequently, we will clean up any typos and spaces that are not required.

```{r}
pop2020$Planning_Area <- gsub("\r\n", "", pop2020$Planning_Area)
pop2020$Subzone <- gsub("\r\n", "", pop2020$Subzone)
pop2020$Subzone <- toupper(pop2020$Subzone)

pop2020$Subzone <- gsub("KANGNORTH", "KANG NORTH", pop2020$Subzone)

pop2020$Planning_Area <- toupper(pop2020$Planning_Area)
pop2020filtered <- pop2020[pop2020$Subzone != "TOTAL",]
```

### 1.2 Importing MPSZ

We want to merge this filtered dataset with mpsz later on, so we will import it now.

```{r}
mpsz <- st_read("data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML.kml")
```

We will now perform pre-processing on the sf layer, including hole removal, as we will need to use the owin later on.

```{r}
mpsz <- mpsz %>%
  mutate(Match=str_match_all(Description,"<td>(.*?)</td>")) %>%
  mutate(Match=map(Match, ~ .[,2])) %>%
  mutate(Match=map(Match,setNames,c("SUBZONE_NO","SUBZONE_N","SUBZONE_C","CA_IND", "PLN_AREA_N", "PLN_AREA_C", "REGION_N", "REGION_C", "INC_CRC", "FMEL_UPD_D"))) %>%
  unnest_wider(Match) %>%
  st_as_sf()

mpsz <- mpsz %>%
  dplyr::select('Name', 'geometry', 'SUBZONE_NO', 'SUBZONE_N', 'SUBZONE_C', 'PLN_AREA_N', 'PLN_AREA_C', 'REGION_N', 'REGION_C')

mpsz <- st_make_valid(mpsz)
mpsz <- st_zm(mpsz)
mpsz <- st_transform(mpsz, crs=3414)
```

```{r}
merged_sg <- st_union(mpsz) %>%
    st_cast("POLYGON")

merged_sg <- merged_sg[c(10)]
merged_sg <- st_remove_holes(merged_sg)
merged_sg <- st_as_sf(merged_sg)

plot(st_geometry(merged_sg))
```

```{r}
merged <- as_Spatial(merged_sg)
merged_sp <- as(merged, "SpatialPolygons")
merged_owin <- as(merged_sp, "owin")
write_rds(merged_owin, "data/rds/merged_owin.rds")
```

### 1.3 Merging Data

Now, we can go back and merge *mpsz* with our filtered *popdata*. Then, rename some columns and combine some age groups for easier display.

```{r}
merged <- merge(mpsz, pop2020filtered, by.x="SUBZONE_N", by.y="Subzone")
colnames(merged)[colnames(merged) == "SUBZONE_N"] <- "Subzone"
colnames(merged)[colnames(merged) == "REGION_N"] <- "Region"
colnames(merged)[colnames(merged) == "Total"] <- "Total Population"

columns_to_replace <- c(
                "0 - 4",
                "5 - 9",
                "10 - 14",
                "15 - 19",
                "20 - 24",
                "25 - 29",
                "30 - 34",
                "35 - 39",
                "40 - 44",
                "45 - 49",
                "50 - 54",
                "55 - 59",
                "60 - 64",
                "65 - 69",
                "70 - 74",
                "75 - 79",
                "80 - 84",
                "85 - 89",
                "90 & Over")

for (col in columns_to_replace) {
  merged[[col]] <- gsub("-", "0", merged[[col]])
}
merged[["Total Population"]] <- gsub("-", "0", merged[["Total Population"]])
for (col in columns_to_replace) {
  merged[[col]] <- as.numeric(merged[[col]])
}

merged$`9 and under` <- merged$`0 - 4` + merged$`5 - 9`
merged$`10-19` <- merged$`10 - 14` + merged$`15 - 19`
merged$`20-29` <- merged$`20 - 24` + merged$`25 - 29`
merged$`30-39` <- merged$`30 - 34` + merged$`35 - 39`
merged$`40-49` <- merged$`40 - 44` + merged$`45 - 49`
merged$`50-59` <- merged$`50 - 54` + merged$`55 - 59`
merged$`60-69` <- merged$`60 - 64` + merged$`65 - 69`
merged$`70 and above` <- merged$`70 - 74` + merged$`75 - 79` + merged$`80 - 84` + merged$`85 - 89` +  + merged$`90 & Over`
merged <- merged[, !colnames(merged) %in% columns_to_replace]
write_rds(pop2020filtered, 'data/rds/pop2020.rds')
write_rds(merged, 'data/rds/merged.rds')
```

## 2.0 KDE

### 2.1 Wrangling Supermarket Data

We will read the supermarket data and perform necessary conversions for plotting into a KDE map. Supermarkets is just one of the variables for the KDE map, we will use it as an example for this exercise. [**The data was pre-processed by my teammate Matthew, you may refer to it [here](https://is415-gaa-matthew-ho.netlify.app/takehomeex/takehomeex3/the3#handling-points).**]{.underline}

```{r}
supermarkets <- read_rds("data/rds/supermarkets.rds")
supermarkets_sp <- as_Spatial(supermarkets)
supermarkets_sp <- as(supermarkets_sp, "SpatialPoints")
supermarkets_ppp <- as(supermarkets_sp, "ppp")
supermarkets_ppp
```

```{r}
plot(supermarkets_ppp)
```

Handling duplicate points:

```{r}
any(duplicated(supermarkets_ppp))
```

```{r}
supermarkets_ppp_jit <- rjitter(supermarkets_ppp,
                                retry=TRUE,
                                nsim=1,
                                drop=TRUE)
any(duplicated(supermarkets_ppp_jit))
```

### 2.2 Combining point events object and owin object

```{r}
merged_owin <- read_rds("data/rds/merged_owin.rds")
supermarketsSG_ppp = supermarkets_ppp[merged_owin]
plot(supermarketsSG_ppp)
```

### 2.3 KDE (Automatic Bandwidth)

```{r}
supermarketsSG_ppp.km <- rescale(supermarketsSG_ppp, 1000, "km")
```

::: panel-tabset
#### bw.diggle()

```{r}
plot(density(supermarketsSG_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="bw.diggle()")
```

#### bw.CvL()

```{r}
plot(density(supermarketsSG_ppp.km, 
             sigma=bw.CvL, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="bw.CvL()")
```

#### bw.scott()

```{r}
plot(density(supermarketsSG_ppp.km, 
             sigma=bw.scott, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="bw.scott()")
```

#### bw.ppl()

```{r}
plot(density(supermarketsSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="bw.ppl()")
```
:::

### 2.4 KDE (Fixed Bandwidth)

```{r}
plot(density(supermarketsSG_ppp.km, 
             sigma=0.6, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Fixed Bandwidth (0.6)")
```

### 2.5 KDE (Adaptive Bandwidth)

```{r}
plot(adaptive.density(supermarketsSG_ppp.km, 
             method="kernel"), 
     main="Adaptive Bandwidth")
```

### 2.6 Converting KDE into Raster

The KDE maps will be displayed in raster map, so I need to first convert it into a gridded object, and then raster. I will be using bw.ppl() automatic bandwidth KDE map as an example, but this will be applied to all KDE maps in the shiny app.

```{r}
kde_supermarketsSG.bw <- density(supermarketsSG_ppp.km,
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian")
```

```{r}
gridded_kde_supermarketsSG_bw <- as.SpatialGridDataFrame.im(kde_supermarketsSG.bw)
spplot(gridded_kde_supermarketsSG_bw)
```

Now that it is a gridded object, I can convert it into RasterLayer object, and then including the CRS information.

```{r}
kde_supermarketsSG_bw_raster <- raster(gridded_kde_supermarketsSG_bw)
kde_supermarketsSG_bw_raster
```

```{r}
projection(kde_supermarketsSG_bw_raster) <- CRS("+init=EPSG:3414 +units=km")
kde_supermarketsSG_bw_raster
```

Now we can plot an interactive KDE map with this raster layer. [**I referenced my classmateKhant's Take-Home Exercise 01 for this section, you may refer to it [here](https://is415-geospatial-with-khant.netlify.app/take-home_ex/take-home_ex01#plotting-interactive-kde-maps).**]{.underline}

```{r}
tmap_mode("view")
tm_basemap(server="OpenStreetMap.HOT") +
  tm_basemap(server = "Esri.WorldImagery") +
  tm_shape(kde_supermarketsSG_bw_raster) +
  tm_raster("v",
            title = "Kernel Density",
            style = "pretty",
            alpha = 0.6,
            palette = c("#fafac3","#fd953b","#f02a75","#b62385","#021c9e")) +
  tm_shape(merged)+
  tm_polygons(alpha=0.1,
              id="PLN_AREA_N", 
              popup.vars=c(
                "Subzone",
                "Region",
                "Total Population",
                "9 and under",
                "10-19",
                "20-29",
                "30-39",
                "40-49",
                "50-59",
                "60-69",
                "70 and above"
              ))+
  tmap_options(check.and.fix = TRUE)
```

## 3.0 Second-Order Spatial Points Pattern Analysis

I will be using the Aljunied subzone for demonstration purposes.

```{r}
mpsz_sp <- as_Spatial(mpsz)
write_rds(mpsz_sp, "data/rds/mpsz_sp.rds")
aj = mpsz_sp[mpsz_sp@data$SUBZONE_N == "ALJUNIED",]
aj_sp = as(aj, "SpatialPolygons")
aj_owin = as(aj_sp, "owin")
aj_ppp = supermarkets_ppp_jit[aj_owin]
```

::: panel-tabset
#### G-function

```{r}
G_aj = Gest(aj_ppp, correction = "border")
plot(G_aj, xlim=c(0,500))
```

#### F-function

```{r}
F_aj = Fest(aj_ppp)
plot(F_aj)
```

#### K-function

```{r}
K_aj = Kest(aj_ppp, correction = "Ripley")
plot(K_aj, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

#### L-function

```{r}
L_aj = Lest(aj_ppp, correction="Ripley")
plot(L_aj, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```
:::

## 4.0 Convert into functions for Shiny

### 4.1 Setting up files

Our group has decided to use maps to make linking simple amenity names to file names, as shown below. This implementation will be used to reference preprocessed files, generated by my teammate Matthew.

```{r}
name2file <- new.env(hash=T, parent=emptyenv())

name2file[["atm"]] <- "poi_atm.rds"
name2file[["bank"]] <- "poi_bank.rds"
name2file[["beauty salon"]] <- "poi_beauty_salon.rds"
name2file[["cafe"]] <- "poi_cafe.rds"
name2file[["clothing store"]] <- "poi_clothing_store.rds"
name2file[["convenience"]] <- "poi_convenience_store.rds"
name2file[["dentist"]] <- "poi_dentist.rds"
name2file[["doctor"]] <- "poi_doctor.rds"
name2file[["gym"]] <- "poi_gym.rds"
name2file[["hospital"]] <- "poi_hospital.rds"
name2file[["library"]] <- "poi_library.rds"
name2file[["lodging"]] <- "poi_lodging.rds"
name2file[["night club"]] <- "poi_night_club.rds"
name2file[["pow"]] <- "poi_place_of_worship.rds"
name2file[["restaurant"]] <- "poi_restaurant.rds"
name2file[["school"]] <- "poi_school.rds"
name2file[["tourist"]] <- "poi_tourist_attraction.rds"

name2file[["bus"]] <- "bus_stop_sg.rds"
name2file[["markets and food centres"]] <- "markets_and_food_centres.rds"
name2file[["mrt"]] <- "mrt.rds"
name2file[["supermarkets"]] <- "supermarkets.rds"
```

### 4.2 KDE Function

```{r}
plot_kde <- function(bandwidth, bandwidthNum, kernel, point_type) {
  merged <- read_rds("data/rds/merged.rds")
  place <- read_rds(paste('data/rds/', name2file[[point_type]], sep="")) %>%
    mutate(capacity = 500)
  place_sp <- as_Spatial(place)
  place_sp <- as(place_sp, "SpatialPoints")
  place_ppp <- as(place_sp, "ppp")
  place_ppp_jit <- rjitter(place_ppp,
                                retry=TRUE,
                                nsim=1,
                                drop=TRUE)
  merged_owin <- read_rds("data/rds/merged_owin.rds")
  placeSG_ppp = place_ppp[merged_owin]
  placeSG_ppp.km <- rescale(placeSG_ppp, 1000, "km")
  if (bandwidth == "fixed") {
    KDE <- density(placeSG_ppp.km, 
             sigma=bandwidthNum, 
             edge=TRUE, 
             kernel=kernel)
  } else if (bandwidth == "adaptive") {
    KDE <- adaptive.density(placeSG_ppp.km, 
             method="kernel")
  } else if (bandwidth == "diggle") {
    KDE <- density(placeSG_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel=kernel)
  } else if (bandwidth == "cvl") {
    KDE <- density(placeSG_ppp.km, 
             sigma=bw.CvL, 
             edge=TRUE, 
             kernel=kernel)
  } else if (bandwidth == "scott") {
    KDE <- density(placeSG_ppp.km, 
             sigma=bw.scott, 
             edge=TRUE, 
             kernel=kernel)
  } else {
    KDE <- density(placeSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel=kernel)
  }
  gridded <- as.SpatialGridDataFrame.im(KDE)
  KDEraster <- raster(gridded)
  projection(KDEraster) <- CRS("+init=EPSG:3414 +units=km")
  tmap_mode("view")
  tm_basemap(server="OpenStreetMap.HOT") +
    tm_basemap(server = "Esri.WorldImagery") +
    tm_shape(KDEraster) +
  tm_raster("v",
            title = "Kernel Density",
            style = "pretty",
            alpha = 0.6,
            palette = c("#fafac3","#fd953b","#f02a75","#b62385","#021c9e")) +
  tm_shape(merged)+
  tm_polygons(alpha=0.1,
              id="PLN_AREA_N", 
              popup.vars=c(
                "Subzone",
                "Region",
                "Total Population",
                "9 and under",
                "10-19",
                "20-29",
                "30-39",
                "40-49",
                "50-59",
                "60-69",
                "70 and above"
              ))+
  tmap_options(check.and.fix = TRUE)
}
```

```{r}
plot_kde("fixed", 0.4, "gaussian", "school")
```

### 4.3 2nd Order SPPA Function

```{r}
plot_sppa <- function(subzone, whichFunction, point_type, nsim) {
  mpsz_sp <- read_rds("data/rds/mpsz_sp.rds")
  sz = mpsz_sp[mpsz_sp@data$SUBZONE_N == toupper(subzone),]
  sz_sp = as(sz, "SpatialPolygons")
  sz_owin = as(sz_sp, "owin")
  place <- read_rds(paste('data/rds/', name2file[[point_type]], sep="")) %>%
    mutate(capacity = 500)
  place_sp <- as_Spatial(place)
  place_sp <- as(place_sp, "SpatialPoints")
  place_ppp <- as(place_sp, "ppp")
  place_ppp_jit <- rjitter(place_ppp,
                                retry=TRUE,
                                nsim=1,
                                drop=TRUE)
  sz_ppp = place_ppp_jit[sz_owin]
  
  if (tolower(whichFunction) == "g") {
    plot(envelope(sz_ppp, Gest, correction="all", nsim=nsim))
  } else if (tolower(whichFunction) == "f") {
    plot(envelope(sz_ppp, Fest, correction="all", nsim=nsim))
  } else if (tolower(whichFunction) == "k") {
    K.csr <- envelope(sz_ppp, Kest, nsim=nsim, rank=1, glocal=TRUE)
    plot(K.csr, . - r ~ r, 
     xlab="d", ylab="K(d)-r", xlim=c(0,500))
  } else {
    L.csr <- envelope(sz_ppp, Lest, nsim=nsim, rank=1, glocal=TRUE)
    plot(L.csr, . - r ~ r, 
     xlab="d", ylab="L(d)-r", xlim=c(0,500))
  }
}
```

```{r}
plot_sppa("aljunied", "f", "doctor", 99)
```

## 5.0 UI Design

### 5.1 KDE

![](images/clipboard-2083650471.png)

This module will be accessible by the navigation bar under SPPA. Above the map, there are 5 tabs for KDE and the different functions. The menu on the left will change depending on which tab is selected, so that the appropriate input fields will be shown. For KDE, the user will be able to select the **point type**, in this case *schools*, the **bandwidth**, which will have a separate field appear when selected as *fixed* bandwidth for the user to input the bandwidth value, as well as the **kernel**, in this case *gaussian*.

### 5.2 Second-Order SPPA

![](images/clipboard-2210365996.png)

For the functions, the menu will be the same - users will be able to select once again the **point type**, in this case *doctors*, the **subzone**, in this case *Aljunied*, and the **number of simulations**, in this case *99*.
