---
title: "Hands-on Exercise 4: Spatial Weights and Applications"
author: "Chester Chia"
---

### 1.1 Setup

For this exercise, we will be using two datasets:

-   Hunan county boundary layer, geospatial dataset in ESRI shapefile format
-   Hunan_2012.csv - contains selected Hunan's local development indicators in 2012

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)
```

### 1.2 Cleaning data

```{r}
hunan <- st_read(dsn="data/geospatial",
                 layer="Hunan")
```

```{r}
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```

Use **left_join()** to update the attribute table of hunan's SpatialPolygonsDataFrame with the attribute fields of hunan2012 dataframe:

```{r}
hunan <- left_join(hunan, hunan2012) %>%
  select(1:4, 7, 15)
```

### 2.1 Visualising Regional Development Indicator

```{r}
basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text("NAME_3", size=0.5)

gdppc <- qtm(hunan, "GDPPC")
tmap_arrange(basemap, gdppc, asp=1, ncol=2)
```

### 2.2 Computing Contiguity Spatial Weights

```{r}
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```

The summary shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours, and two area units with only 1 neighbour.

To list neighboring polygons, we can use **wm_q**:

```{r}
wm_q[[1]]
```

The numbers represent the polygon IDs. We can retrieve county name as well:

```{r}
hunan$County[1]
```

```{r}
hunan$NAME_3[c(2,3,4,57,85)]
```

We can retrieve the GDPPC of these five countries:

```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```

```{r}
str(wm_q)
```

Compute Rook contiguity weight matrix:

```{r}
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)
```

### 2.3 Visualising contiguity weights

A connectivity graph takes a point and displays a line to each neighboring point. Since we are working with polygons, we need to get points in order to make our graphs. The most common method is to use polygon centroids, which we will calculate in the sf package before moving onto the graphs.

We first need points to associate with each polygon - it is more complicated than just running **st_centroid** on the sf object. We need the coordinates in a separate data frame for this to work. To do this, we will use a mapping function which applies a given function to each element of a vector and returns a vector of the same length. Our input vector will be the geometry column of us.bound. Our function will be **st_centroid**. We will be using **map_dbl** variation of map from the *purrr* package.

```{r}
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
```

```{r}
coords <- cbind(longitude, latitude)
```

```{r}
head(coords)
```

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
```

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey", main="Queen Contiguity")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
plot(hunan$geometry, border="lightgrey", main="Rook Contiguity")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

### 2.4 Computing distance based neghbours

Determine the upper limit for distance band:

-   Return a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using *knearneigh()* of **spdep**.
-   Convert the knn object returned by *knearneigh()* into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using *knn2nb()*.
-   Return the length of neighbour relationship edges by using *nbdists()* of **spdep**. The function returns in the units of the coordinates if the coordinates are projected, in km otherwise.
-   Remove the list structure of the returned object by using **unlist()**.

```{r}
#coords <- coordinates(hunan)
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

```{r}
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm_d62
```

```{r}
str(wm_d62)
```

```{r}
table(hunan$County, card(wm_d62))
```

Distance weight matrix:

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE)
plot(k1, coords, add=TRUE, col="red", length=0.08)
```

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey", main="1st nearest neighbours")
plot(k1, coords, add=TRUE, col="red", length=0.08)
plot(hunan$geometry, border="lightgrey", main="Distance link")
plot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6)
```

It is possible to control the numbers of neighbours directly using k-nearest neighbours, either accepting asymmetric neighbours or imposing symmetry as shown in the code chunk below.

```{r}
knn6 <- knn2nb(knearneigh(coords, k=6))
knn6
```

```{r}
str(knn6)
```

Plotting weight matrix:

```{r}
plot(hunan$geometry, border="lightgrey")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

### 2.5 Weights based on IDW

First, compute distance between areas using **nbdists()**

```{r}
dist <- nbdists(wm_q, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))
ids
```

Next, need to assign weights to each neighbouring polygon. In our case, they will be assigned equal weight. This is accomplished by assigning the fraction 1/#ofneighbours to each neighbouring county, then summing the weighted income values.

```{r}
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q
```

```{r}
rswm_q$weights[10]
```

Using the same method, we can also derive a row standardised distance weight matrix:

```{r}
rswm_ids <- nb2listw(wm_q, glist=ids, style="B", zero.policy=TRUE)
rswm_ids
```

```{r}
rswm_ids$weights[1]
```

```{r}
summary(unlist(rswm_ids$weights))
```

### 2.6 Application of Spatial Weight Matrix

In this section, we will learn to create four different spatial lagged variables:

-   spatial lag with row-standardized weights,
-   spatial lag as a sum of neighbouring values,
-   spatial window average, and
-   spatial window sum

### 2.6.1 Spatial lag with row-standardized weights

```{r}
GDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)
GDPPC.lag
```

```{r}
lag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))
lag.res <- as.data.frame(lag.list)
colnames(lag.res) <- c("NAME_3", "lag GDPPC")
hunan <- left_join(hunan,lag.res)
```

```{r}
head(hunan)
```

```{r}
gdppc <- qtm(hunan, "GDPPC")
lag_gdppc <- qtm(hunan, "lag GDPPC")
tmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)
```

### 2.6.2 **Spatial lag as a sum of neighboring values**

We can calculate by assigning binary weights - requires us to go back to neighbors list, then apply a function that will assign binary weights, and use glist = in the nb2listw function to explicitly assign these weights.

```{r}
b_weights <- lapply(wm_q, function(x) 0*x + 1)
b_weights2 <- nb2listw(wm_q, 
                       glist = b_weights, 
                       style = "B")
b_weights2
```

```{r}
lag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))
lag.res <- as.data.frame(lag_sum)
colnames(lag.res) <- c("NAME_3", "lag_sum GDPPC")
```

```{r}
lag_sum
```

```{r}
hunan <- left_join(hunan, lag.res)
```

```{r}
gdppc <- qtm(hunan, "GDPPC")
lag_sum_gdppc <- qtm(hunan, "lag_sum GDPPC")
tmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)
```

### 2.6.3 **Spatial window average**

Uses row-standardized weights and includes the diagonal element, we need to go back to the neighbors structure and add the diagonal element before assigning weights.

```{r}
wm_qs <- include.self(wm_q)
```

```{r}
wm_qs[[1]]
```

```{r}
wm_qs <- nb2listw(wm_qs)
wm_qs
```

```{r}
lag_w_avg_gpdpc <- lag.listw(wm_qs, 
                             hunan$GDPPC)
lag_w_avg_gpdpc
```

```{r}
lag.list.wm_qs <- list(hunan$NAME_3, lag.listw(wm_qs, hunan$GDPPC))
lag_wm_qs.res <- as.data.frame(lag.list.wm_qs)
colnames(lag_wm_qs.res) <- c("NAME_3", "lag_window_avg GDPPC")
```

```{r}
hunan <- left_join(hunan, lag_wm_qs.res)
```

```{r}
hunan %>%
  select("County", 
         "lag GDPPC", 
         "lag_window_avg GDPPC") %>%
  kable()
```

```{r}
w_avg_gdppc <- qtm(hunan, "lag_window_avg GDPPC")
tmap_arrange(lag_gdppc, w_avg_gdppc, asp=1, ncol=2)
```

### 2.6.4 Spatial Window Sum

```{r}
wm_qs <- include.self(wm_q)
wm_qs
```

```{r}
b_weights <- lapply(wm_qs, function(x) 0*x + 1)
b_weights[1]
```

```{r}
b_weights2 <- nb2listw(wm_qs, 
                       glist = b_weights, 
                       style = "B")
b_weights2
```

```{r}
w_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))
w_sum_gdppc
```

```{r}
w_sum_gdppc.res <- as.data.frame(w_sum_gdppc)
colnames(w_sum_gdppc.res) <- c("NAME_3", "w_sum GDPPC")
```

```{r}
hunan <- left_join(hunan, w_sum_gdppc.res)
```

```{r}
hunan %>%
  select("County", "lag_sum GDPPC", "w_sum GDPPC") %>%
  kable()
```

```{r}
w_sum_gdppc <- qtm(hunan, "w_sum GDPPC")
tmap_arrange(lag_sum_gdppc, w_sum_gdppc, asp=1, ncol=2)
```
