---
title: "Hands-On Exercise 5: 2nd Order Spatial Point Patterns Analysis Methods"
author: "Chester Chia"
execute:
  warning: false
---

## 1.0 Setup

### 1.1 Requirements

-   **sf** - import, manage, and process vector-based geospatial data in R
-   **spatstat** - used to perform 1st and 2nd order spatial point patterns analysis and derive kernel density estimation (KDE) layer
-   **raster** - used to convert image output generated by spatstat into raster format
-   **maptools** - used to convert *Spatial* objects into *ppp* format of **spatstat**
-   **tmap** - provides functions for plotting cartographic quality static point patterns maps or interactive maps using the leaflet API

### 1.2 Importing and loading the packages

```{r}
pacman::p_load(maptools, sf, raster, spatstat, tmap)
```

After installing the packages, we will import our geospatial data sets using **st_read()** and change the reference system where needed

```{r}
childcare_sf <- st_read("data/ChildCareServices.geojson") %>%   st_transform(crs = 3414)
```

```{r}
sg_sf <- st_read(dsn="data", layer="CostalOutline") %>%   st_transform(crs=3414)
```

```{r}
mpsz_sf <- st_read(dsn="data", layer="MP14_SUBZONE_WEB_PL") %>%   st_transform(crs=3414)
```

Checking system information of `sg_sf` and `mpsz_sf`

```{r}
st_crs(sg_sf)
```

```{r}
st_crs(mpsz_sf)
```

## 2.0 Mapping the datasets

```{r}
tm_shape(sg_sf) +   tm_polygons() +   tm_shape(mpsz_sf) +   tm_polygons() +   tm_shape(childcare_sf) +   tm_dots()
```

Alternatively, we can prepare a pin map:

```{r}
# tmap_mode('view') # tm_shape(childcare_sf) +  #  tm_dots() # tmap_mode('plot')
```

It allows us to navigate and zoom around the map freely, and provides information of each simple feature on click.

## 3.0 Geospatial Data Wrangling

### 3.1 Converting sf data frames to sp's Spatial class

```{r}
childcare <- as_Spatial(childcare_sf) 
mpsz <- as_Spatial(mpsz_sf) 
sg <- as_Spatial(sg_sf)
```

```{r}
childcare
```

```{r}
mpsz
```

```{r}
sg
```

### 3.2 Converting the Spatial class into generic sp format

**spatstat** requires the data in ***ppp*** object form. However, there is no direct way to convert a Spatial class into a ***ppp*** object, so we need to convert it into ***Spatial*** object first.

```{r}
childcare_sp <- as(childcare, "SpatialPoints") 
sg_sp <- as(sg, "SpatialPolygons")
```

```{r}
childcare_sp
```

```{r}
sg_sp
```

### 3.3 Converting the generic sp format into spatstat's ppp format

```{r}
childcare_ppp <- as(childcare_sp, "ppp") 
childcare_ppp
```

```{r}
plot(childcare_ppp)
```

```{r}
summary(childcare_ppp)
```

::: callout-caution
Notice the warning about duplicates - in spatial point patterns analysis, the presence of duplicates are an issue of significance. The statistical methodology used for spatial point patterns processes is based largely on the assumption that processes are *simple*, that is, the points cannot be coincident.
:::

### 3.4 Handling duplicated points

We can check for duplicates in a ***ppp*** object:

```{r}
any(duplicated(childcare_ppp))
```

Using **multiplicity()** to count the number of co-incidence points:

```{r}
# multiplicity(childcare_ppp) 
sum(multiplicity(childcare_ppp) > 1)
```

To view the locations of these duplicate point events, we will plot `childcare` data like this:

```{r}
tmap_mode("view") 
tm_shape(childcare) +   
  tm_dots(alpha=0.4,           
          size=0.05)
```

```{r}
tmap_mode('plot')
```

There are 3 ways to overcome this problem:

1.  Delete the duplicates, but risk deleting some useful point events
2.  ***jittering***, which will add a small perturbation to the duplicate points so that they do not occupy the exact same space
3.  Make each point "unique" and then attach the duplicates of the points to the patterns as **marks**, as attributes of the points.

Jittering approach:

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp,
                             retry=TRUE,
                             nsim=1,
                             drop=TRUE)
```

```{r}
any(duplicated(childcare_ppp_jit))
```

### 3.5 Creating ***owin*** object

It is a good practice to confine the analysis of spatial point patterns with a geographical area like Singapore boundary. In **spatstat**, an object called **owin** is specially designed to represent this polygonal region.

```{r}
sg_owin <- as(sg_sp, "owin")
plot(sg_owin)
```

```{r}
summary(sg_owin)
```

### 3.6 Combining point events object and owin object

We will extract childcare events that are located within Singapore:

```{r}
childcareSG_ppp <- childcare_ppp[sg_owin] 
summary(childcareSG_ppp)
```

```{r}
plot(childcareSG_ppp)
```

#### 3.6.1 Extracting study area

```{r}
pg = mpsz[mpsz@data$PLN_AREA_N == "PUNGGOL",] 
tm = mpsz[mpsz@data$PLN_AREA_N == "TAMPINES",] 
ck = mpsz[mpsz@data$PLN_AREA_N == "CHOA CHU KANG",] 
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]
```

```{r}
par(mfrow=c(2,2), mar=c(3,3,1,1)) 
plot(pg, main = "Ponggol") 
plot(tm, main = "Tampines") 
plot(ck, main = "Choa Chu Kang") 
plot(jw, main = "Jurong West")
```

#### 3.6.2 Converting the spatial point data frame into generic sp format

```{r}
pg_sp = as(pg, "SpatialPolygons")
tm_sp = as(tm, "SpatialPolygons")
ck_sp = as(ck, "SpatialPolygons") 
jw_sp = as(jw, "SpatialPolygons")
```

#### 3.6.3 Creating owin object

```{r}
pg_owin = as(pg_sp, "owin")
tm_owin = as(tm_sp, "owin")
ck_owin = as(ck_sp, "owin")
jw_owin = as(jw_sp, "owin")
```

#### 3.6.4 Combining childcare points and the study area

```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

```{r}
childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")
```

```{r}
par(mfrow=c(2,2), mar=c(3,3,1,1))
plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang") 
plot(childcare_jw_ppp.km, main="Jurong West")
```

#### 

## 4.0 Second Order Spatial Point Patterns Analysis

### 4.1 Analysing Spatial Point Process using G-Function

G function measures the distribution of the distances from an arbitrary event to its nearest event. We will be using **Gest()** of **spatstat** package to compute G-function, and use **envelope()** to perform monta carlo simulation test.

#### 4.1.1 CCK Planning Area

```{r}
G_CK = Gest(childcare_ck_ppp, correction = "border")
plot(G_CK, xlim=c(0,500))
```

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho - the distribution of childcare services at Choa Chu Kang are randomly distributed

H1 - the distribution of childcare services at Choa Chu Kang is not randomly distributed

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

Monte Carlo test with G-function:

```{r}
G_CK.csr <- envelope(childcare_ck_ppp, Gest, nsim = 999)
```

```{r}
plot(G_CK.csr)
```

#### 4.1.2 Tampines Planning Area

```{r}
G_tm = Gest(childcare_tm_ppp, correction = "best")
plot(G_tm)
```

We will perform a similar hypothesis test:

```{r}
G_tm.csr <- envelope(childcare_tm_ppp, Gest, correction = "all", nsim = 999)
```

```{r}
plot(G_tm.csr)
```

### 4.2 Analysing Spatial Point Process using F-Function

The F function estimates the empty space function F(r) or its hazard rate h(r) from a point pattern in a window of arbitrary shape. We will be using **Fest()** to compute the F-function, and **envelope()** to perform the simulation test.

#### 4.2.1 CCK Planning Area

```{r}
F_CK = Fest(childcare_ck_ppp)
plot(F_CK)
```

```{r}
F_CK.csr <- envelope(childcare_ck_ppp, Fest, nsim = 999)
```

```{r}
plot(F_CK.csr)
```

#### 4.2.2 Tampines Planning Area

```{r}
F_tm = Fest(childcare_tm_ppp, correction = "best")
plot(F_tm)
```

```{r}
F_tm.csr <- envelope(childcare_tm_ppp, Fest, correction = "all", nsim = 999)
```

```{r}
plot(F_tm.csr)
```

### 4.3 **Analysing Spatial Point Process Using K-Function**

K-function measures the number of events found up to a given distance of any particular event. We will be using **kest()** to compute k-function and **envelope()** again for simulation.

#### 4.3.1 CCK Planning Area

```{r}
K_ck = Kest(childcare_ck_ppp, correction = "Ripley")
plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

```{r}
K_ck.csr <- envelope(childcare_ck_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(K_ck.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

#### 4.3.2 Tampines Planning Area

```{r}
K_tm = Kest(childcare_tm_ppp, correction = "Ripley")
plot(K_tm, . -r ~ r, 
     ylab= "K(d)-r", xlab = "d(m)", 
     xlim=c(0,1000))
```

```{r}
K_tm.csr <- envelope(childcare_tm_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(K_tm.csr, . - r ~ r, 
     xlab="d", ylab="K(d)-r", xlim=c(0,500))
```

### 4.4 **Analysing Spatial Point Process Using L-Function**

Finally, we will be using **lest()** to compute L-function estimation.

#### 4.4.1 CCK Planning Area

```{r}
L_ck = Lest(childcare_ck_ppp, correction = "Ripley")
plot(L_ck, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

```{r}
L_ck.csr <- envelope(childcare_ck_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_ck.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

#### 4.4.2 Tampines Planning Area

```{r}
L_tm = Lest(childcare_tm_ppp, correction = "Ripley")
plot(L_tm, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)", 
     xlim=c(0,1000))
```

```{r}
L_tm.csr <- envelope(childcare_tm_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_tm.csr, . - r ~ r, 
     xlab="d", ylab="L(d)-r", xlim=c(0,500))
```
