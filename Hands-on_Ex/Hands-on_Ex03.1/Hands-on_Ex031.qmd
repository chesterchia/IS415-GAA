---
title: "Hands-on Exercise 4: 1st Order Spatial Point Patterns Analysis Methods"
author: "Chester Chia"
execute: 
  warning: false
---

## 1.0 Setup

### 1.1 Requirements

-   **sf** - import, manage, and process vector-based geospatial data in R
-   **spatstat** - used to perform 1st and 2nd order spatial point patterns analysis and derive kernel density estimation (KDE) layer
-   **raster** - used to convert image output generated by spatstat into raster format
-   **maptools** - used to convert *Spatial* objects into *ppp* format of **spatstat**
-   **tmap** - provides functions for plotting cartographic quality static point patterns maps or interactive maps using the leaflet API

### 1.2 Importing and loading the packages

```{r}
pacman::p_load(maptools, sf, raster, spatstat, tmap)
```

After installing the packages, we will import our geospatial data sets using **st_read()** and change the reference system where needed

```{r}
childcare_sf <- st_read("data/ChildCareServices.geojson") %>%
  st_transform(crs = 3414)
```

```{r}
sg_sf <- st_read(dsn="data", layer="CostalOutline") %>%
  st_transform(crs=3414)
```

```{r}
mpsz_sf <- st_read(dsn="data", layer="MP14_SUBZONE_WEB_PL") %>%
  st_transform(crs=3414)
```

Checking system information of `sg_sf` and `mpsz_sf`

```{r}
st_crs(sg_sf)
```

```{r}
st_crs(mpsz_sf)
```

## 2.0 Mapping the datasets

```{r}
tm_shape(sg_sf) +
  tm_polygons() +
  tm_shape(mpsz_sf) +
  tm_polygons() +
  tm_shape(childcare_sf) +
  tm_dots()
```

Alternatively, we can prepare a pin map:

```{r}
# tmap_mode('view')
# tm_shape(childcare_sf) + 
#  tm_dots()
# tmap_mode('plot')
```

It allows us to navigate and zoom around the map freely, and provides information of each simple feature on click.

## 3.0 Geospatial Data Wrangling

### 3.1 Converting sf data frames to sp's Spatial class

```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```

```{r}
childcare
```

```{r}
mpsz
```

```{r}
sg
```

### 3.2 Converting the Spatial class into generic sp format

**spatstat** requires the data in ***ppp*** object form. However, there is no direct way to convert a Spatial class into a ***ppp*** object, so we need to convert it into ***Spatial*** object first.

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

```{r}
childcare_sp
```

```{r}
sg_sp
```

### 3.3 Converting the generic sp format into spatstat's ppp format

```{r}
childcare_ppp <- as(childcare_sp, "ppp")
childcare_ppp
```

```{r}
plot(childcare_ppp)
```

```{r}
summary(childcare_ppp)
```

::: callout-caution
Notice the warning about duplicates - in spatial point patterns analysis, the presence of duplicates are an issue of significance. The statistical methodology used for spatial point patterns processes is based largely on the assumption that processes are *simple*, that is, the points cannot be coincident.
:::

### 3.4 Handling duplicated points

We can check for duplicates in a ***ppp*** object:

```{r}
any(duplicated(childcare_ppp))
```

Using **multiplicity()** to count the number of co-incidence points:

```{r}
# multiplicity(childcare_ppp)
sum(multiplicity(childcare_ppp) > 1)
```

To view the locations of these duplicate point events, we will plot `childcare` data like this:

```{r}
tmap_mode("view")
tm_shape(childcare) +
  tm_dots(alpha=0.4,
          size=0.05)
```

```{r}
tmap_mode('plot')
```

There are 3 ways to overcome this problem:

1.  Delete the duplicates, but risk deleting some useful point events
2.  ***jittering***, which will add a small perturbation to the duplicate points so that they do not occupy the exact same space
3.  Make each point "unique" and then attach the duplicates of the points to the patterns as **marks**, as attributes of the points.

Jittering approach:

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp,
                             retry=TRUE,
                             nsim=1,
                             drop=TRUE)
```

```{r}
any(duplicated(childcare_ppp_jit))
```

### 3.5 Creating ***owin*** object

It is a good practice to confine the analysis of spatial point patterns with a geographical area like Singapore boundary. In **spatstat**, an object called **owin** is specially designed to represent this polygonal region.

```{r}
sg_owin <- as(sg_sp, "owin")
plot(sg_owin)
```

```{r}
summary(sg_owin)
```

### 3.6 Combining point events object and owin object

We will extract childcare events that are located within Singapore:

```{r}
childcareSG_ppp <- childcare_ppp[sg_owin]
summary(childcareSG_ppp)
```

```{r}
plot(childcareSG_ppp)
```

## 4.0 First-order Spatial Point Patterns Analysis

### 4.1 Kernel Density Estimation

#### 4.1.1 Computing KDE using automatic bandwidth selection method

The code below computes kernel density using the following configurations of **density()** of **spatstat**:

-   **bw.diggle()** automatic bandwidth selection method
-   The smoothing kernel used is *gaussian*, which is the default. Other methods include *epanechnikov*, *quartic*, or *disc*
-   The intensity estimate is corrected for edge effect bias by using a method described by Jones and Diggle, the default is *FALSE*

```{r}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                              kernel="gaussian")
plot(kde_childcareSG_bw)
```

The density values of the output range from 0 to 0.000035 which is too small to comprehend, as the default unit of measurement of **svy21** is meter. Thus, the density values computed are in "number of points per square meter".

::: callout-tip
You can retrieve the bandwidth used to compute the kde layer by using the code below:
:::

```{r}
bw <- bw.diggle(childcareSG_ppp)
bw
```

#### 4.1.2 Rescaling KDE values

**rescale()** can be used to convert the unit of measurement from meter to kilometer:

```{r}
childcareSG_ppp.km <- rescale(childcareSG_ppp, 1000, "km")
kde_childcareSG.bw <- density(childcareSG_ppp.km,
                              sigma=bw.diggle,
                              edge=TRUE,
                              kernel="gaussian")
plot(kde_childcareSG.bw)
```

### 4.2 Working with different automatic bandwidth methods

Besides **bw.diggle()**, there are three other **spatstat** functions that can be used to determine the bandwidth: **bw.CvL()**, **bw.scott()**, and **bw.pp()**

```{r}
bw.CvL(childcareSG_ppp.km)
```

```{r}
bw.scott(childcareSG_ppp.km)
```

```{r}
bw.ppl(childcareSG_ppp.km)
```

```{r}
bw.diggle(childcareSG_ppp.km)
```

Comparing the output of using **bw.diggle** and **bw.ppl**

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp.km,
                               sigma=bw.ppl,
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main="bw.diggle")
plot(kde_childcareSG.ppl, main="bw.ppl")
```

### 4.3 Working with different kernel methods

By default, the kernel method used in **density.ppp()** is *gaussian*. But there are three other options - *Epanechnikov*, *Quartic*, and *Dics*.

We will compute three more KDEs by using these three functions:

```{r}
par(mfrow=c(2,2), mar=c(3,3,1,1))
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

## 5.0 Fixed and Adaptive KDE

### 5.1 Computing KDE by using fixed bandwidth

```{r}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG_600)
```

### 5.2 Computing KDE using adaptive bandwidth

Fixed bandwidth method is very sensitive to highly skewed distribution of spatial point patterns over geographical units, for example urban vs rural. One way to overcome this problem is by using adaptive bandwidth.

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```

Comparing KDE outputs:

```{r}
par(mfrow=c(1, 2))
plot(kde_childcareSG.bw, main="Fixed bandwidth")
plot(kde_childcareSG_adaptive, main="Adaptive bandwidth")
```

### 5.3 Converting KDE output into grid object

```{r}
gridded_kde_childcareSG_bw <- as.SpatialGridDataFrame.im(kde_childcareSG.bw)
spplot(gridded_kde_childcareSG_bw)
```

#### 5.3.1 Converting gridded output into raster

Converting the gridded kernel density objects into RasterLayer objects

```{r}
kde_childcareSG_bw_raster <- raster(gridded_kde_childcareSG_bw)
kde_childcareSG_bw_raster
```

#### 5.3.2 Assigning projection systems

```{r}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```

### 5.4 Visualising the output in tmap

```{r}
tm_shape(kde_childcareSG_bw_raster) +
  tm_raster("v") + 
  tm_layout(legend.position = c("right", "bottom"), frame=FALSE)
```

::: callout-note
Notice the raster values are encoded explicitly onto the raster pixel using the values in "v" field
:::

### 5.5 Comparing Spatial Point Patterns using KDE

We will be comparing KDE of childcare at Punggol, Tampines, CCK and Jurong West planning areas.

#### 5.5.1 Extracting study area

```{r}
pg = mpsz[mpsz@data$PLN_AREA_N == "PUNGGOL",]
tm = mpsz[mpsz@data$PLN_AREA_N == "TAMPINES",]
ck = mpsz[mpsz@data$PLN_AREA_N == "CHOA CHU KANG",]
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]
```

```{r}
par(mfrow=c(2,2), mar=c(3,3,1,1))
plot(pg, main = "Ponggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```

#### 5.5.2 Converting the spatial point data frame into generic sp format

```{r}
pg_sp = as(pg, "SpatialPolygons")
tm_sp = as(tm, "SpatialPolygons")
ck_sp = as(ck, "SpatialPolygons")
jw_sp = as(jw, "SpatialPolygons")
```

#### 5.5.3 Creating owin object

```{r}
pg_owin = as(pg_sp, "owin")
tm_owin = as(tm_sp, "owin")
ck_owin = as(ck_sp, "owin")
jw_owin = as(jw_sp, "owin")
```

#### 5.5.4 Combining childcare points and the study area

```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

```{r}
childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")
```

```{r}
par(mfrow=c(2,2), mar=c(3,3,1,1))
plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang")
plot(childcare_jw_ppp.km, main="Jurong West")
```

#### 5.5.5 Computing KDE

```{r}
par(mfrow=c(2,2), mar=c(3,3,1,1))
plot(density(childcare_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tempines")
plot(density(childcare_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
```

#### 5.5.6 Computing fixed bandwidth KDE

For comparison purposes, we will use 250m as the bandwidth

```{r}
par(mfrow=c(2,2), mar=c(3,3,1,1))
plot(density(childcare_ck_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Chou Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
plot(density(childcare_pg_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
```

## 6.0 Nearest Neighbour Analysis

We will perform the Clark-Evans test of aggregation for a spatial point pattern by using **clarkevans.test()** of **spatstat.**

The test hypotheses are:

-   Ho - the distribution of childcare services are randomly distributed
-   H1 - the distribution of childcare services are not randomly distributed

The 95% confident interval will be used.

### 6.1 Testing spatial point patterns using Clark and Evans Test

```{r}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

The test statistic (R) measures the degree of clustering in the point pattern.

The p-value is a measure of the evidence against the null hypothesis. A very small p-value suggests strong evidence against the null hypothesis.

As such, given the **small p-value**, we would reject the null hypothesis - the evidence suggests the childcare locations are **not randomly distributed** and instead exhibit a clustered pattern.

### 6.2 Clark and Evans Test: CCK planning area

```{r}
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

### 6.3 Clark and Evans Test: Tampines planning area

```{r}
clarkevans.test(childcare_tm_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```
