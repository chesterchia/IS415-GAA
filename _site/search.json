[
  {
    "objectID": "In-class_Ex/In-class_Ex04/In-class_Ex04.html",
    "href": "In-class_Ex/In-class_Ex04/In-class_Ex04.html",
    "title": "In-class Exercise 4",
    "section": "",
    "text": "pacman::p_load(sf, spdep, tmap, tidyverse, knitr, GWmodel)\n\n\nhunan &lt;- st_read(dsn=\"data/geospatial\",\n                 layer=\"Hunan\")\n\nReading layer `Hunan' from data source \n  `C:\\chesterchia\\IS415-GAA\\In-class_Ex\\In-class_Ex04\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\nhunan2012 &lt;- read_csv(\"data/aspatial/Hunan_2012.csv\")\n\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nhunan &lt;- left_join(hunan, hunan2012) %&gt;%\n  select(1:4, 7, 15)\n\nJoining with `by = join_by(County)`\n\n\n\nWorking with GWSS\n\nhunan_sp &lt;- hunan %&gt;%\n  as_Spatial()\n\n\ngwstat &lt;- gwss(data = hunan_sp,\n               vars = \"GDPPC\",\n               bw = 6,\n               kernel = \"bisquare\",\n               adaptive = TRUE,\n               longlat = T)\n\n\n\nRecap from Hands-on Exercise 4\n\nbasemap &lt;- tm_shape(hunan) + #no output, just read into memory\n  tm_polygons() + #plot out polygons\n  tm_text(\"NAME_3\", size=0.5) #county name and font size\n\n\ngdppc &lt;- qtm(hunan, \"GDPPC\")\ntmap_arrange(basemap, gdppc, asp=1, ncol=2) #use tmap to arrange 2 maps into 1 row, 2 col\n\n\n\n\n\nwm_q &lt;- poly2nb(hunan, queen=TRUE) #list of polygon and its neighbours based on internal id using queen's case\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\n\nwm_q[[1]] #gives neighbours of id=1\n\n[1]  2  3  4 57 85\n\n\nTo get name, must use hunan, not wm_q which is a list and does not contain the name:\n\nhunan$County[1] #retrieves county name of id=\n\n[1] \"Anxiang\"\n\n\n\nhunan$NAME_3[c(2,3,4,57,85)] #names of five neighbouring polygons\n\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n\n\n\nwm_r &lt;- poly2nb(hunan, queen=FALSE) #uses rook case instead\nsummary(wm_r) #number of links will be reduced as compared to using queen's case\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n\n\nFor fixed distance, determine cut-off distance.\n\nlongitude &lt;- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\nlatitude &lt;- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\ncoords &lt;- cbind(longitude, latitude)\nk1 &lt;- knn2nb(knearneigh(coords)) #calculate nearest neighbour\nk1dists &lt;- unlist(nbdists(k1, coords, longlat = TRUE)) \nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nUse largest distance as cut off, round up (61.79 ~ 62)\n\nwm_d62 &lt;- dnearneigh(coords, 0, 62, longlat = TRUE) #anything &lt;62km considered neighbour\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\n\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\", main=\"1st nearest neighbours\")\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08)\nplot(hunan$geometry, border=\"lightgrey\", main=\"Distance link\")\nplot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6)\n\n\n\n\n\nknn6 &lt;- knn2nb(knearneigh(coords, k=6))\nknn6\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 528 \nPercentage nonzero weights: 6.818182 \nAverage number of links: 6 \nNon-symmetric neighbours list\n\n\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")\n\n\n\n\n\nrswm_q &lt;- nb2listw(wm_q, style=\"W\", zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\n\nlag.list &lt;- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))\nlag.res &lt;- as.data.frame(lag.list)\ncolnames(lag.res) &lt;- c(\"NAME_3\", \"lag GDPPC\")\nhunan &lt;- left_join(hunan,lag.res)\n\nJoining with `by = join_by(NAME_3)`\n\n\n\ngdppc &lt;- qtm(hunan, \"GDPPC\")\nlag_gdppc &lt;- qtm(hunan, \"lag GDPPC\")\ntmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)\n\n\n\n\n\nb_weights &lt;- lapply(wm_q, function(x) 0*x + 1)\nb_weights2 &lt;- nb2listw(wm_q, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n\n\n\nlag_sum &lt;- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nlag.res &lt;- as.data.frame(lag_sum)\ncolnames(lag.res) &lt;- c(\"NAME_3\", \"lag_sum GDPPC\")\n\n\nhunan &lt;- left_join(hunan, lag.res)\n\nJoining with `by = join_by(NAME_3)`\n\ngdppc &lt;- qtm(hunan, \"GDPPC\")\nlag_sum_gdppc &lt;- qtm(hunan, \"lag_sum GDPPC\")\ntmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "Human mobility, the movement of human beings in space and time, reflects the spatial-temporal characteristics of human behavior. With the advancement Information and Communication Technologies (ICT) especially smart phone, a large volume of data related to human mobility have been collected. By using appropriate GIS analysis methods, these data are potentially useful in supporting smart city planning and management.\nIn Singapore, one of the important source of data related to human mobility is from Land Transport Authority (LTA) DataMall. Two data sets related to human mobility are provided by the portal, they are: Passenger Volume by Origin Destination Train Stations and Passenger Volume by Origin Destination Bus Stops. One of the limitation of these data sets is that their location are biased to either bus stops or MRT/LRT stations. In 2020, another very interesting human mobility data set called Grab Posisi was released by GRAB, one of the largest shared taxi operator in South-east Asia. There are two data sets been released and one of them is for Singapore\n\n\nThe tasks of this take-home exercise are as follows:\n\nUsing appropriate function of sf and tidyverse, preparing the following geospatial data layer in sf tibble data.frames:\n\nGrab taxi location points either by origins or destinations.\nRoad layer within Singapore excluding outer islands.\nSingapore boundary layer excluding outer islands\n\nUsing the extracted data, derive traditional Kernel Density Estimation layers.\nUsing the extracted data, derive either Network Kernel Density Estimation (NKDE) or Temporal Network Kernel Density Estimation (TNKDE)\nUsing appropriate tmap functions, display the kernel density layers on openstreetmap of Singapore.\nDescribe the spatial patterns revealed by the kernel density maps."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#overview",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#overview",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "Human mobility, the movement of human beings in space and time, reflects the spatial-temporal characteristics of human behavior. With the advancement Information and Communication Technologies (ICT) especially smart phone, a large volume of data related to human mobility have been collected. By using appropriate GIS analysis methods, these data are potentially useful in supporting smart city planning and management.\nIn Singapore, one of the important source of data related to human mobility is from Land Transport Authority (LTA) DataMall. Two data sets related to human mobility are provided by the portal, they are: Passenger Volume by Origin Destination Train Stations and Passenger Volume by Origin Destination Bus Stops. One of the limitation of these data sets is that their location are biased to either bus stops or MRT/LRT stations. In 2020, another very interesting human mobility data set called Grab Posisi was released by GRAB, one of the largest shared taxi operator in South-east Asia. There are two data sets been released and one of them is for Singapore\n\n\nThe tasks of this take-home exercise are as follows:\n\nUsing appropriate function of sf and tidyverse, preparing the following geospatial data layer in sf tibble data.frames:\n\nGrab taxi location points either by origins or destinations.\nRoad layer within Singapore excluding outer islands.\nSingapore boundary layer excluding outer islands\n\nUsing the extracted data, derive traditional Kernel Density Estimation layers.\nUsing the extracted data, derive either Network Kernel Density Estimation (NKDE) or Temporal Network Kernel Density Estimation (TNKDE)\nUsing appropriate tmap functions, display the kernel density layers on openstreetmap of Singapore.\nDescribe the spatial patterns revealed by the kernel density maps."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#setup",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#setup",
    "title": "Take-Home Exercise 1",
    "section": "2.0 Setup",
    "text": "2.0 Setup\n\n2.1 Installing packages\n\npacman::p_load(arrow, tidyverse, sf, tmap, maptools, spatstat, stringr, nngeo, spNetwork, viridis, classInt, gifski)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#data-wrangling",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#data-wrangling",
    "title": "Take-Home Exercise 1",
    "section": "3.0 Data Wrangling",
    "text": "3.0 Data Wrangling\n\n3.1 Importing data\n\nImporting the Grab Posisi Dataset\n\ngrabp &lt;- open_dataset(\"data/aspatial/GrabPosisi/\") %&gt;%\n  as.data.frame()\n\n\n\nImporting the OSM dataset\n\nosm = st_read(\"data/geospatial/malaysia-singapore-brunei-latest-free.shp\",\n              layer=\"gis_osm_roads_free_1\")\n\nReading layer `gis_osm_roads_free_1' from data source \n  `C:\\chesterchia\\IS415-GAA\\Take-home_Ex\\Take-home_Ex01\\data\\geospatial\\malaysia-singapore-brunei-latest-free.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1765176 features and 10 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 99.66041 ymin: 0.8021131 xmax: 119.2601 ymax: 7.514393\nGeodetic CRS:  WGS 84\n\n\n\n\nImporting the Master Plan Subzone Dataset\n\nmpsz &lt;- st_read(\"data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML.kml\")\n\nReading layer `URA_MP19_SUBZONE_NO_SEA_PL' from data source \n  `C:\\chesterchia\\IS415-GAA\\Take-home_Ex\\Take-home_Ex01\\data\\geospatial\\MasterPlan2019SubzoneBoundaryNoSeaKML.kml' \n  using driver `KML'\nSimple feature collection with 332 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY, XYZ\nBounding box:  xmin: 103.6057 ymin: 1.158699 xmax: 104.0885 ymax: 1.470775\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\nSince each description field is embedded in HTML, I’ll be using the third method from this article to parse the data.\n\nmpsz &lt;- mpsz %&gt;%\n  mutate(Match=str_match_all(Description,\"&lt;td&gt;(.*?)&lt;/td&gt;\")) %&gt;%\n  mutate(Match=map(Match, ~ .[,2])) %&gt;%\n  mutate(Match=map(Match,setNames,c(\"SUBZONE_NO\",\"SUBZONE_N\",\"SUBZONE_C\",\"CA_IND\", \"PLN_AREA_N\", \"PLN_AREA_C\", \"REGION_N\", \"REGION_C\", \"INC_CRC\", \"FMEL_UPD_D\"))) %&gt;%\n  unnest_wider(Match) %&gt;%\n  st_as_sf()\n\nI can then select only the data I need and drop the unnecessary fields.\n\nmpsz &lt;- mpsz %&gt;%\n  dplyr::select('Name', 'geometry', 'SUBZONE_NO', 'SUBZONE_N', 'SUBZONE_C', 'PLN_AREA_N', 'PLN_AREA_C', 'REGION_N', 'REGION_C')\n\nNow, let us check for invalid geometries:\n\nlength(which(st_is_valid(mpsz) == FALSE))\n\n[1] 6\n\n\n\nmpsz &lt;- st_make_valid(mpsz)\nmpsz &lt;- st_zm(mpsz)\n\n\n\n\n3.2 Wrangling\n\nGrabPosisi\nAlthough the GrabPosisi dataset consists of many fields, we are only interested in the origin and destinations. To do this, we can first convert the timestamp into datetime format, and then sort it ascending/descending and retrieving the first row. This will give us the earliest and latest points.\n\ngrabp$pingtimestamp &lt;- as_datetime(grabp$pingtimestamp, tz=\"Asia/Singapore\")\n\n\norigin_df &lt;- grabp %&gt;%\n  group_by(trj_id) %&gt;%\n  arrange(pingtimestamp) %&gt;%\n  filter(row_number()==1) %&gt;%\n  mutate(weekday = wday(pingtimestamp,\n                        label=TRUE,\n                        abbr=TRUE),\n         start_hr = factor(hour(pingtimestamp)),\n         day = factor(mday(pingtimestamp))) %&gt;%\n  st_as_sf(coords = c(\"rawlng\", \"rawlat\"),\n                      crs = 4326) %&gt;%\n  st_transform(crs = 3414)\n\ndestination_df &lt;- grabp %&gt;%\n  group_by(trj_id) %&gt;%\n  arrange(desc(pingtimestamp)) %&gt;%\n  filter(row_number()==1) %&gt;%\n  mutate(weekday = wday(pingtimestamp,\n                        label=TRUE,\n                        abbr=TRUE),\n         end_hr = factor(hour(pingtimestamp)),\n         day = factor(mday(pingtimestamp))) %&gt;%\n  st_as_sf(coords = c(\"rawlng\", \"rawlat\"),\n                      crs = 4326) %&gt;%\n  st_transform(crs = 3414)\n\nHere are what the origin and destination dataframes look like after converting it:\n\nhead(origin_df)\n\nSimple feature collection with 6 features and 10 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 17201.85 ymin: 29236.55 xmax: 31518.05 ymax: 47967.97\nProjected CRS: SVY21 / Singapore TM\n# A tibble: 6 × 11\n# Groups:   trj_id [6]\n  trj_id driving_mode osname pingtimestamp        speed bearing accuracy weekday\n  &lt;chr&gt;  &lt;chr&gt;        &lt;chr&gt;  &lt;dttm&gt;               &lt;dbl&gt;   &lt;int&gt;    &lt;dbl&gt; &lt;ord&gt;  \n1 70895  car          andro… 2019-04-08 08:09:26  9.95      111      4   Mon    \n2 21926  car          andro… 2019-04-08 08:09:48 11.0        75      4   Mon    \n3 47498  car          ios    2019-04-08 08:09:50 18.6       307      8   Mon    \n4 18103  car          andro… 2019-04-08 08:09:55  0.404     159      3   Mon    \n5 41322  car          andro… 2019-04-08 08:09:57 17.9       232      3.9 Mon    \n6 64813  car          ios    2019-04-08 08:10:03 17.1       106     10   Mon    \n# ℹ 3 more variables: start_hr &lt;fct&gt;, day &lt;fct&gt;, geometry &lt;POINT [m]&gt;\n\n\n\nhead(destination_df)\n\nSimple feature collection with 6 features and 10 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 14101.2 ymin: 33097.49 xmax: 44192.98 ymax: 46866.96\nProjected CRS: SVY21 / Singapore TM\n# A tibble: 6 × 11\n# Groups:   trj_id [6]\n  trj_id driving_mode osname  pingtimestamp       speed bearing accuracy weekday\n  &lt;chr&gt;  &lt;chr&gt;        &lt;chr&gt;   &lt;dttm&gt;              &lt;dbl&gt;   &lt;int&gt;    &lt;dbl&gt; &lt;ord&gt;  \n1 81574  car          ios     2019-04-22 07:56:49 15.3      103     8    Mon    \n2 54687  car          android 2019-04-22 07:56:46  8.15     299     4.55 Mon    \n3 17190  car          android 2019-04-22 07:56:36 12.4      202     4    Mon    \n4 13793  car          android 2019-04-22 07:56:30  6.47     170     3.9  Mon    \n5 39014  car          ios     2019-04-22 07:56:27  3.59     169     4    Mon    \n6 41170  car          ios     2019-04-22 07:56:13 13.1       71     5    Mon    \n# ℹ 3 more variables: end_hr &lt;fct&gt;, day &lt;fct&gt;, geometry &lt;POINT [m]&gt;\n\n\nOnce again, it is good practice to drop columns that we don’t require.\n\norigin_df &lt;- origin_df %&gt;%\n  dplyr::select('trj_id', 'pingtimestamp', 'geometry', 'weekday', 'start_hr', 'day')\ndestination_df &lt;- destination_df %&gt;%\n  dplyr::select('trj_id', 'pingtimestamp', 'geometry', 'weekday', 'end_hr', 'day')\n\nWe will then save the dataframes into an rds file to save memory, which we can retrieve next time for future use.\n\nwrite_rds(origin_df, \"data/rds/origin_df.rds\")\nwrite_rds(destination_df, \"data/rds/destination_df.rds\")\n\n\norigin_df &lt;- read_rds(\"data/rds/origin_df.rds\")\ndestination_df &lt;- read_rds(\"data/rds/destination_df.rds\")\n\n\n\nOpen Street Maps\nSince we are interested in road layers, we can look at a summary of the fclass column in our data.\n\nunique(osm$fclass)\n\n [1] \"primary\"        \"secondary\"      \"residential\"    \"service\"       \n [5] \"track\"          \"tertiary\"       \"footway\"        \"primary_link\"  \n [9] \"motorway_link\"  \"tertiary_link\"  \"motorway\"       \"unclassified\"  \n[13] \"trunk\"          \"trunk_link\"     \"secondary_link\" \"pedestrian\"    \n[17] \"living_street\"  \"path\"           \"steps\"          \"cycleway\"      \n[21] \"track_grade2\"   \"track_grade4\"   \"track_grade1\"   \"track_grade3\"  \n[25] \"unknown\"        \"track_grade5\"   \"bridleway\"     \n\n\nWe can drop the classes that are not roads to reduce the size of our dataset. To know which are roads, we can refer to section 5.2 of geofrabik’s documentation. I have included roads used by vehicles, and have excluded the rest including classes that I was unable to find in the documentation.\n\nto_keep &lt;- c(\"primary\", \"secondary\", \"residential\", \"service\", \"track\", \"tertiary\", \"primary_link\", \"motorway_link\", \"motorway\", \"trunk\", \"trunk_link\", \"secondary_link\", \"living_street\")\nosm &lt;- osm %&gt;%\n  filter(fclass %in% to_keep)\n\nTo confirm that we have reduced our dataset:\n\nunique(osm$fclass)\n\n [1] \"primary\"        \"secondary\"      \"residential\"    \"service\"       \n [5] \"track\"          \"tertiary\"       \"primary_link\"   \"motorway_link\" \n [9] \"motorway\"       \"trunk\"          \"trunk_link\"     \"secondary_link\"\n[13] \"living_street\" \n\n\nAnd finally, we can drop columns that we don’t need.\n\nosm &lt;- osm %&gt;%\n  dplyr::select(\"osm_id\", \"fclass\")\n\n\n\n3.3 Verifying + Transforming Coordinate System\nLet us check the coordinate system of mpsz and osm:\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\n\n\nst_crs(osm)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"latitude\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"longitude\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\n\nSince they are not SVY21, we will change them.\n\nmpsz &lt;- st_transform(mpsz, crs=3414)\nosm &lt;- st_transform(osm, crs=3414)\n\n\n\n3.4 Removing Outer Islands\n\nplot(st_geometry(mpsz))\n\n\n\n\nAs we can see from this plot, there are islands surrounding Singapore that are not connected to the mainland by road, such as Pulau Tekong and Pulau Ubin - these are our “outer islands” that we will exclude.\nThe most straightforward way to do this would be to use st_union to create a single multipolygon encompassing all areas, then select a specific part that represents the mainland, which in our case would be the largest polygon (10th one). We can then fill in the holes using st_remove_holes from the nngeo package.\n\nmerged_sg &lt;- st_union(mpsz) %&gt;%\n    st_cast(\"POLYGON\")\n\nmerged_sg &lt;- merged_sg[c(10)]\nmerged_sg &lt;- st_remove_holes(merged_sg)\nmerged_sg &lt;- st_as_sf(merged_sg)\n\nplot(st_geometry(merged_sg))\n\n\n\n\n\n\n3.5 Preparing for KDE\nWe can now create an owin object for KDE later on, and save it into an RDS for future use.\n\nmerged &lt;- as_Spatial(merged_sg)\nmerged_sp &lt;- as(merged, \"SpatialPolygons\")\nmerged_owin &lt;- as(merged_sp, \"owin\")\nwrite_rds(merged_owin, \"data/rds/merged_owin.rds\")\n\nWe can now remove the data on Malaysian and Bruneian roads, and subsequently also save this into an RDS.\n\nosm_sg &lt;- st_intersection(osm, merged_sg)\n\nAn issue that I ran into is that some geometry was saved as MULTILINESTRING, which caused an error when calculating NKDE.\n\nsummary(osm_sg)\n\n    osm_id             fclass                     geometry     \n Length:158955      Length:158955      LINESTRING     :158888  \n Class :character   Class :character   MULTILINESTRING:    67  \n Mode  :character   Mode  :character   epsg:3414      :     0  \n                                       +proj=tmer...  :     0  \n\n\nAs such, I’ll split each of those geometry into LINESTRINGs.\n\nosm_sg &lt;- st_cast(st_cast(osm_sg, \"MULTILINESTRING\"), \"LINESTRING\")\nsummary(osm_sg)\n\n    osm_id             fclass                   geometry     \n Length:159027      Length:159027      LINESTRING   :159027  \n Class :character   Class :character   epsg:3414    :     0  \n Mode  :character   Mode  :character   +proj=tmer...:     0  \n\n\n\nwrite_rds(osm_sg, \"data/rds/osm_sg.rds\")\nosm_sg &lt;- read_rds(\"data/rds/osm_sg.rds\")\n\nFinally, we can convert our data to ppp objects, before checking for duplicates.\n\norigin &lt;- as_Spatial(origin_df)\ndestination &lt;- as_Spatial(destination_df)\n\norigin_sp &lt;- as(origin, \"SpatialPoints\")\ndestination_sp &lt;- as(destination, \"SpatialPoints\")\n\norigin_ppp &lt;- as(origin_sp, \"ppp\")\ndestination_ppp &lt;- as(destination_sp, \"ppp\")\n\norigin_ppp &lt;- origin_ppp[merged_owin]\ndestination_ppp &lt;- destination_ppp[merged_owin]\n\n\nany(duplicated(origin_ppp))\n\n[1] FALSE\n\n\n\nany(duplicated(destination_ppp))\n\n[1] FALSE"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "IS415-GAA",
    "section": "",
    "text": "Welcome to IS415 Geospatial Analytics and Applications\nThis is the course website of IS415 I study this term. You will find my course work on this website."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#kde",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#kde",
    "title": "Take-Home Exercise 1",
    "section": "4.0 KDE",
    "text": "4.0 KDE\nWe can now finally perform KDE for our origin and destinations. I’ll use an automatically decided bandwidth with the four different methods, Gaussian, Epanechnikov, Quartic, and Disc, and plot them side by side.\n\nOriginDestination\n\n\n\norigin_ppp.km &lt;- rescale(origin_ppp, 1000, \"km\")\npar(mfrow=c(2,2), mar=c(3,3,1,3))\nplot(density(origin_ppp.km, \n             sigma=bw.diggle, \n             edge=TRUE, \n             kernel=\"gaussian\"), \n     main=\"Gaussian\")\nplot(density(origin_ppp.km, \n             sigma=bw.diggle, \n             edge=TRUE, \n             kernel=\"epanechnikov\"), \n     main=\"Epanechnikov\")\nplot(density(origin_ppp.km, \n             sigma=bw.diggle, \n             edge=TRUE, \n             kernel=\"quartic\"), \n     main=\"Quartic\")\nplot(density(origin_ppp.km, \n             sigma=bw.diggle, \n             edge=TRUE, \n             kernel=\"disc\"), \n     main=\"Disc\")\n\n\n\n\n\n\n\ndestination_ppp.km &lt;- rescale(destination_ppp, 1000, \"km\")\npar(mfrow=c(2,2), mar=c(3,3,1,3))\nplot(density(destination_ppp.km, \n             sigma=bw.diggle, \n             edge=TRUE, \n             kernel=\"gaussian\"), \n     main=\"Gaussian\")\nplot(density(destination_ppp.km, \n             sigma=bw.diggle, \n             edge=TRUE, \n             kernel=\"epanechnikov\"), \n     main=\"Epanechnikov\")\nplot(density(destination_ppp.km, \n             sigma=bw.diggle, \n             edge=TRUE, \n             kernel=\"quartic\"), \n     main=\"Quartic\")\nplot(density(destination_ppp.km, \n             sigma=bw.diggle, \n             edge=TRUE, \n             kernel=\"disc\"), \n     main=\"Disc\")\n\n\n\n\n\n\n\nAs seen from the above plots, majority of the map was relatively dark, except for Changi Airport which is where many Grab trips depart from and arrive to.\nIf we recall from our Hands-on Exercise, Baddeley et. (2016) suggested the use of the bw.ppl() algorithm because in ther experience it tends to produce the more appropriate values when the pattern consists predominantly of tight clusters. But they also insist that if the purpose of once study is to detect a single tight cluster in the midst of random noise then the bw.diggle() method seems to work best.\nLet us compare the output using both.\n\nOriginDestination\n\n\n\norigin_ppp.km &lt;- rescale(origin_ppp, 1000, \"km\")\norigin.bw &lt;- density(origin_ppp.km,\n                     sigma=bw.diggle,\n                     edge=TRUE,\n                     kernel=\"gaussian\")\norigin.ppl &lt;- density(origin_ppp.km,\n                      sigma=bw.ppl,\n                      edge=TRUE,\n                      kernel=\"gaussian\")\npar(mfrow=c(1,2))\nplot(origin.bw, main=\"bw.diggle\")\nplot(origin.ppl, main=\"bw.ppl\")\n\n\n\n\n\n\n\ndestination_ppp.km &lt;- rescale(destination_ppp, 1000, \"km\")\ndestination.bw &lt;- density(destination_ppp.km,\n                     sigma=bw.diggle,\n                     edge=TRUE,\n                     kernel=\"gaussian\")\ndestination.ppl &lt;- density(destination_ppp.km,\n                      sigma=bw.ppl,\n                      edge=TRUE,\n                      kernel=\"gaussian\")\npar(mfrow=c(1,2))\nplot(destination.bw, main=\"bw.diggle\")\nplot(destination.ppl, main=\"bw.ppl\")\n\n\n\n\n\n\n\nAs seen from the above plots, there is not much difference in the two bandwidths - both are relatively dark. This suggests the bandwidth used might be slightly too small, resulting in a high level of sensitivity to local fluctuations and noise in the data. In order to make the map more interpretable, I will use a higher bandwidth which should light up the map and make the overall pattern of the data more apparent.\n\nOriginDestination\n\n\n\norigin_ppp.km &lt;- rescale(origin_ppp, 1000, \"km\")\norigin.bw &lt;- density(origin_ppp.km,\n                     sigma=0.6,\n                     edge=TRUE,\n                     kernel=\"gaussian\")\nplot(origin.bw)\n\n\n\n\n\n\n\ndestination_ppp.km &lt;- rescale(destination_ppp, 1000, \"km\")\ndestination.bw &lt;- density(destination_ppp.km,\n                     sigma=0.6,\n                     edge=TRUE,\n                     kernel=\"gaussian\")\nplot(destination.bw)\n\n\n\n\n\n\n\nHere are my observations from the KDE:\n\nNotably illuminated areas on the maps were identified at Changi Airport, primarily due to the substantial traffic volume, irrespective of whether it was the point of origin or destination.\nA bright area was also observed in the Central Business District (CBD).\nThe illuminated regions in the northern part of the map could be linked to Woodlands Checkpoint, along with the geographical distance from the Yishun/Sembawang/Canberra areas to the CBD. Consequently, more people were observed to be using Grab services for commuting to and from work.\nThe bright spots in the western part of the map were potentially associated with office complexes in the Jurong East area. Additionally, the Choa Chu Kang area, being relatively distant from the CBD, contributed to increased Grab activity."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#nkde",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#nkde",
    "title": "Take-Home Exercise 1",
    "section": "5.0 NKDE",
    "text": "5.0 NKDE\n\n5.1 Study Area\nBased on our observations from the KDE, we will be using the following zones for NKDE:\n\nChangi Airport - CHANGI\nCBD - DOWNTOWN CORE\nWoodlands (incl. checkpoint) - WOODLANDS\nJurong East - JURONG EAST\n\n\n\n5.2 Changi Airport\nBefore we begin, let’s restrict our NKDE to just the Changi area, while using st_intersection to ensure that the area is limited to the mainland, as well as identifying the features in the OSM data that fall within the bounds of the Changi area.\n\nchangi &lt;- mpsz %&gt;%\n  filter(PLN_AREA_N==\"CHANGI\")\nchangi &lt;- st_intersection(changi, merged_sg)\nosm_changi &lt;- st_intersection(osm_sg, changi)\nosm_changi_index &lt;- as.numeric(osm_changi$osm_id)\nosm_changi &lt;- osm_sg[osm_sg$osm_id %in% osm_changi_index, ]\n\nplot(osm_changi)\n\n\n\n\nWe can then intersect Changi and the destination/origin data frames:\n\nOriginDestination\n\n\n\norigin_df.changi &lt;- st_intersection(origin_df, changi)\ndestination_df.changi &lt;- st_intersection(destination_df, changi)\nplot(origin_df.changi)\n\n\n\n\n\n\n\nplot(destination_df.changi)\n\n\n\n\n\n\n\nWe can also visualize the data using tmap.\n\nOriginDestination\n\n\n\ntm_shape(osm_changi) +\n  tm_lines() +\ntm_shape(origin_df.changi) +\n  tm_dots(col=\"orange\")\n\n\n\n\n\n\n\ntm_shape(osm_changi) +\n  tm_lines() +\ntm_shape(destination_df.changi) +\n  tm_dots(col=\"orange\")\n\n\n\n\n\n\n\n\nNKDE Calculation\n\nlixels &lt;- lixelize_lines(osm_changi, 700, mindist=350)\nsamples &lt;- lines_center(lixels)\n\n\ndensities.origin &lt;- nkde(osm_changi,\n                         events=origin_df.changi,\n                         w=rep(1, nrow(origin_df.changi)),\n                         samples=samples,\n                         kernel_name=\"quartic\",\n                         bw=300,\n                         div=\"bw\",\n                         method=\"simple\",\n                         digits=1,\n                         tol=1,\n                         grid_shape=c(1,1),\n                         max_depth=8,\n                         agg=5,\n                         sparse=TRUE,\n                         verbose=FALSE\n                         )\ndensities.destination &lt;- nkde(osm_changi,\n                         events=destination_df.changi,\n                         w=rep(1, nrow(destination_df.changi)),\n                         samples=samples,\n                         kernel_name=\"quartic\",\n                         bw=300,\n                         div=\"bw\",\n                         method=\"simple\",\n                         digits=1,\n                         tol=1,\n                         grid_shape=c(1,1),\n                         max_depth=8,\n                         agg=5,\n                         sparse=TRUE,\n                         verbose=FALSE\n                         )\n\n\nsamples$density.origin &lt;- densities.origin*1000\nsamples$density.destination &lt;- densities.destination*1000\nlixels$density.origin &lt;- densities.origin*1000\nlixels$density.destination &lt;- densities.destination*1000\n\n\nOriginDestination\n\n\n\ntm_shape(lixels) +\n  tm_lines(col=\"density.origin\")\n\n\n\n\n\n\n\ntm_shape(lixels) +\n  tm_lines(col=\"density.destination\")\n\n\n\n\n\n\n\nAs we can see from the visualization, a large concentration of the density was at the dropoff/pickup points of Changi Airport, as everywhere else was so light that it was unable to be seen. The only glaring difference between both origin and destination was that for destination, we can see the density actually stretch to the bend before the drop off point. As such, I went into Google Street View and found this:\n\nAs you can see from the street view, this stretch of the map is actually still the highway leading to the airport, and it makes no sense for passengers to actually be alighting here. My hypothesis is that the grab drivers are intentionally “ending” the trip in the app slightly early, so that they are able to quickly search for more pickups.\n\n\n\n5.3 CBD\nWe will be doing the same data preparation for the CBD area.\n\ncbd &lt;- mpsz %&gt;%\n  filter(PLN_AREA_N==\"DOWNTOWN CORE\")\nchangi &lt;- st_intersection(cbd, merged_sg)\nosm_cbd &lt;- st_intersection(osm_sg, cbd)\nosm_cbd_index &lt;- as.numeric(osm_cbd$osm_id)\nosm_cbd &lt;- osm_sg[osm_sg$osm_id %in% osm_cbd_index, ]\n\nplot(osm_cbd)\n\n\n\n\n\ndestination_df.cbd = st_intersection(destination_df, cbd)\norigin_df.cbd = st_intersection(origin_df, cbd)\n\n\nOriginDestination\n\n\n\ntm_shape(osm_cbd) + \n  tm_lines() +\ntm_shape(origin_df.cbd) +\n  tm_dots(col = \"orange\")\n\n\n\n\n\n\n\ntm_shape(osm_cbd) + \n  tm_lines() +\ntm_shape(destination_df.cbd) +\n  tm_dots(col = \"orange\")\n\n\n\n\n\n\n\n\nNKDE Calculation\n\nlixels &lt;- lixelize_lines(osm_cbd, 700, mindist=350)\nsamples &lt;- lines_center(lixels)\n\n\ndensities.origin &lt;- nkde(osm_cbd,\n                         events=origin_df.cbd,\n                         w=rep(1, nrow(origin_df.cbd)),\n                         samples=samples,\n                         kernel_name=\"quartic\",\n                         bw=300,\n                         div=\"bw\",\n                         method=\"simple\",\n                         digits=1,\n                         tol=1,\n                         grid_shape=c(1,1),\n                         max_depth=8,\n                         agg=5,\n                         sparse=TRUE,\n                         verbose=FALSE\n                         )\ndensities.destination &lt;- nkde(osm_cbd,\n                         events=destination_df.cbd,\n                         w=rep(1, nrow(destination_df.cbd)),\n                         samples=samples,\n                         kernel_name=\"quartic\",\n                         bw=300,\n                         div=\"bw\",\n                         method=\"simple\",\n                         digits=1,\n                         tol=1,\n                         grid_shape=c(1,1),\n                         max_depth=8,\n                         agg=5,\n                         sparse=TRUE,\n                         verbose=FALSE\n                         )\n\n\nsamples$density.origin &lt;- densities.origin*1000\nsamples$density.destination &lt;- densities.destination*1000\nlixels$density.origin &lt;- densities.origin*1000\nlixels$density.destination &lt;- densities.destination*1000\n\n\nOriginDestination\n\n\n\ntm_shape(lixels) +\n  tm_lines(col=\"density.origin\")\n\n\n\n\n\n\n\ntm_shape(lixels) +\n  tm_lines(col=\"density.destination\")\n\n\n\n\n\n\n\n\n\nUsing the above image as reference, we can see that the intersections around Raffles Place have very high density for the origins - likely due to the fact that many office complexes are located in or around the building itself. The northern part of the district where Nicoll Highway intersects Rochor Flyover is also very dense, for both destination and origin. This is due to where the CBD area is situated, with many office buildings such as Guoco Tower all being in this area.\n\n\n\n5.4 Woodlands\nWe will be doing the same data preparation for the woodlands area.\n\nwoodlands &lt;- mpsz %&gt;%\n  filter(PLN_AREA_N==\"WOODLANDS\") \nwoodlands &lt;- st_intersection(woodlands, merged_sg)\nosm_woodlands &lt;- st_intersection(osm_sg, woodlands) \nosm_woodlands_index &lt;- as.numeric(osm_woodlands$osm_id) \nosm_woodlands &lt;- osm_sg[osm_sg$osm_id %in% osm_woodlands_index, ]  \nplot(osm_woodlands)\n\n\n\n\n\ndestination_df.woodlands = st_intersection(destination_df, woodlands) \norigin_df.woodlands = st_intersection(origin_df, woodlands)\n\n\nOriginDestination\n\n\n\ntm_shape(osm_woodlands) +\n  tm_lines() + \ntm_shape(origin_df.woodlands) +\n  tm_dots(col = \"orange\")\n\n\n\n\n\n\n\ntm_shape(osm_woodlands) +\n  tm_lines() +\ntm_shape(destination_df.woodlands) +\n  tm_dots(col = \"orange\")\n\n\n\n\n\n\n\n\nNKDE Calculation\n\nlixels &lt;- lixelize_lines(osm_woodlands, 700, mindist=350) \nsamples &lt;- lines_center(lixels)\n\n\ndensities.origin &lt;- nkde(osm_woodlands,\n                         events=origin_df.woodlands,\n                         w=rep(1, nrow(origin_df.woodlands)),\n                         samples=samples,\n                         kernel_name=\"quartic\",\n                         bw=300,\n                         div=\"bw\",\n                         method=\"simple\",\n                         digits=1,\n                         tol=1,\n                         grid_shape=c(1,1),\n                         max_depth=8,\n                         agg=5,\n                         sparse=TRUE,\n                         verbose=FALSE\n) \ndensities.destination &lt;- nkde(osm_woodlands,\n                              events=destination_df.woodlands,\n                              w=rep(1, nrow(destination_df.woodlands)),\n                              samples=samples,\n                              kernel_name=\"quartic\",\n                              bw=300,\n                              div=\"bw\",\n                              method=\"simple\",\n                              digits=1,\n                              tol=1,\n                              grid_shape=c(1,1),\n                              max_depth=8,\n                              agg=5,\n                              sparse=TRUE,                          \n                              verbose=FALSE     \n)\n\n\nsamples$density.origin &lt;- densities.origin*1000 \nsamples$density.destination &lt;- densities.destination*1000 \nlixels$density.origin &lt;- densities.origin*1000 \nlixels$density.destination &lt;- densities.destination*1000\n\n\nOriginDestination\n\n\n\ntm_shape(lixels) + \n  tm_lines(col=\"density.origin\")\n\n\n\n\n\n\n\ntm_shape(lixels) +  \n  tm_lines(col=\"density.destination\")\n\n\n\n\n\n\n\nWe can address two very obvious hotspots. First, the hotspot in the west area.\n\n\n\nIn both the origin and destinations, the area around Marsiling MRT is the most dense - suggesting that there might be a lack of efficient transportation around the area from the station, hence people resulting to using Grab. In the origin, there is another hotspot right below the Woodlands checkpoint, suggesting most people Grab from the checkpoint rather than to, perhaps due to fatigue from working/leisuring in Johor Bahru.\n\n\n\nLastly, there is a hotspot in Central Woodlands. This can obviously be attributed to the MRT station, but we can also deduce that the majority of residents are staying in the central area.\n\n\n\n5.5 Jurong East\nWe will be doing the same data preparation for the jurong east area.\n\nje &lt;- mpsz %&gt;%   \n  filter(PLN_AREA_N==\"JURONG EAST\")  \nje &lt;- st_intersection(je, merged_sg) \nosm_je &lt;- st_intersection(osm_sg, je)  \nosm_je_index &lt;- as.numeric(osm_je$osm_id)  \nosm_je &lt;- osm_sg[osm_sg$osm_id %in% osm_je_index, ]\nplot(osm_je)\n\n\n\n\n\ndestination_df.je = st_intersection(destination_df, je)\norigin_df.je = st_intersection(origin_df, je)\n\n\nOriginDestination\n\n\n\ntm_shape(osm_je) +   \n  tm_lines() +\ntm_shape(origin_df.je) +\n  tm_dots(col = \"orange\")\n\n\n\n\n\n\n\ntm_shape(osm_je) +\n  tm_lines() +\ntm_shape(destination_df.je) +\n  tm_dots(col = \"orange\")\n\n\n\n\n\n\n\n\nNKDE Calculation\n\nlixels &lt;- lixelize_lines(osm_je, 700, mindist=350)\nsamples &lt;- lines_center(lixels)\n\n\ndensities.origin &lt;- nkde(osm_je,\n                         events=origin_df.je,\n                         w=rep(1, nrow(origin_df.je)),\n                         samples=samples,\n                         kernel_name=\"quartic\",\n                         bw=300, \n                         div=\"bw\",   \n                         method=\"simple\",  \n                         digits=1,          \n                         tol=1,           \n                         grid_shape=c(1,1),  \n                         max_depth=8,     \n                         agg=5,            \n                         sparse=TRUE,   \n                         verbose=FALSE \n)\ndensities.destination &lt;- nkde(osm_je,\n                              events=destination_df.je,\n                              w=rep(1, nrow(destination_df.je)),\n                              samples=samples,              \n                              kernel_name=\"quartic\",       \n                              bw=300,                     \n                              div=\"bw\",              \n                              method=\"simple\",    \n                              digits=1,        \n                              tol=1,          \n                              grid_shape=c(1,1),       \n                              max_depth=8,           \n                              agg=5,               \n                              sparse=TRUE,   \n                              verbose=FALSE  \n)\n\n\nsamples$density.origin &lt;- densities.origin*1000\nsamples$density.destination &lt;- densities.destination*1000 \nlixels$density.origin &lt;- densities.origin*1000 \nlixels$density.destination &lt;- densities.destination*1000\n\n\nOriginDestination\n\n\n\ntm_shape(lixels) +\n  tm_lines(col=\"density.origin\")\n\n\n\n\n\n\n\ntm_shape(lixels) +  \n  tm_lines(col=\"density.destination\")\n\n\n\n\n\n\n\n\nWith reference to the above image, there are two main areas of interest. The first is on the extreme north-east of the region, where IMM is situated. Being the largest outlet mall in Singapore, it is no surprise that there is a hotspot around this area, with shoppers grabbing to and fro.\nThe other is along Jurong Town Hall Road. My initial suspicions of office complexes was wrong - the two junctions that intersect it on the map that are hotspots both have little to no office buildings, and are mostly residential - specifically, there were a lot of condominium complexes. A possibility for the high amounts of trips originating and ending along this stretch could be due to a lack of efficient public transport around the area, or simply a high concentration of Jurong East residents staying in the area."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#cbd",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#cbd",
    "title": "Take-Home Exercise 1",
    "section": "5.3 CBD",
    "text": "5.3 CBD\nWe will be doing the same data preparation for the CBD area.\n\ncbd &lt;- mpsz %&gt;%\n  filter(PLN_AREA_N==\"DOWNTOWN CORE\")\nchangi &lt;- st_intersection(cbd, merged_sg)\nosm_cbd &lt;- st_intersection(osm_sg, cbd)\nosm_cbd_index &lt;- as.numeric(osm_cbd$osm_id)\nosm_cbd &lt;- osm_sg[osm_sg$osm_id %in% osm_cbd_index, ]\n\nplot(osm_cbd)\n\n\n\n\n\ndestination_df.cbd = st_intersection(destination_df, cbd)\norigin_df.cbd = st_intersection(origin_df, cbd)\n\n\nOriginDestination\n\n\n\ntm_shape(osm_cbd) + \n  tm_lines() +\ntm_shape(origin_df.cbd) +\n  tm_dots(col = \"orange\")\n\n\n\n\n\n\n\ntm_shape(osm_cbd) + \n  tm_lines() +\ntm_shape(destination_df.cbd) +\n  tm_dots(col = \"orange\")\n\n\n\n\n\n\n\n\nNKDE Calculation\n\nlixels &lt;- lixelize_lines(osm_cbd, 700, mindist=350)\nsamples &lt;- lines_center(lixels)\n\n\ndensities.origin &lt;- nkde(osm_cbd,\n                         events=origin_df.cbd,\n                         w=rep(1, nrow(origin_df.cbd)),\n                         samples=samples,\n                         kernel_name=\"quartic\",\n                         bw=300,\n                         div=\"bw\",\n                         method=\"simple\",\n                         digits=1,\n                         tol=1,\n                         grid_shape=c(1,1),\n                         max_depth=8,\n                         agg=5,\n                         sparse=TRUE,\n                         verbose=FALSE\n                         )\ndensities.destination &lt;- nkde(osm_cbd,\n                         events=destination_df.cbd,\n                         w=rep(1, nrow(destination_df.cbd)),\n                         samples=samples,\n                         kernel_name=\"quartic\",\n                         bw=300,\n                         div=\"bw\",\n                         method=\"simple\",\n                         digits=1,\n                         tol=1,\n                         grid_shape=c(1,1),\n                         max_depth=8,\n                         agg=5,\n                         sparse=TRUE,\n                         verbose=FALSE\n                         )\n\n\nsamples$density.origin &lt;- densities.origin*1000\nsamples$density.destination &lt;- densities.destination*1000\nlixels$density.origin &lt;- densities.origin*1000\nlixels$density.destination &lt;- densities.destination*1000\n\n\nOriginDestination\n\n\n\ntm_shape(lixels) +\n  tm_lines(col=\"density.origin\")\n\n\n\n\n\n\n\ntm_shape(lixels) +\n  tm_lines(col=\"density.destination\")\n\n\n\n\n\n\n\n\n\nUsing the above image as reference, we can see that the intersections around Raffles Place have very high density for the origins - likely due to the fact that many office complexes are located in or around the building itself. The northern part of the district where Nicoll Highway intersects Rochor Flyover is also very dense, for both destination and origin. This is due to where the CBD area is situated, with many office buildings such as Guoco Tower all being in this area."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#woodlands",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#woodlands",
    "title": "Take-Home Exercise 1",
    "section": "5.4 Woodlands",
    "text": "5.4 Woodlands\nWe will be doing the same data preparation for the woodlands area.\n\nwoodlands &lt;- mpsz %&gt;%\n  filter(PLN_AREA_N==\"WOODLANDS\") \nwoodlands &lt;- st_intersection(woodlands, merged_sg)\nosm_woodlands &lt;- st_intersection(osm_sg, woodlands) \nosm_woodlands_index &lt;- as.numeric(osm_woodlands$osm_id) \nosm_woodlands &lt;- osm_sg[osm_sg$osm_id %in% osm_woodlands_index, ]  \nplot(osm_woodlands)\n\n\n\n\n\ndestination_df.woodlands = st_intersection(destination_df, woodlands) \norigin_df.woodlands = st_intersection(origin_df, woodlands)\n\n\nOriginDestination\n\n\n\ntm_shape(osm_woodlands) +\n  tm_lines() + \ntm_shape(origin_df.woodlands) +\n  tm_dots(col = \"orange\")\n\n\n\n\n\n\n\ntm_shape(osm_woodlands) +\n  tm_lines() +\ntm_shape(destination_df.woodlands) +\n  tm_dots(col = \"orange\")\n\n\n\n\n\n\n\n\nNKDE Calculation\n\nlixels &lt;- lixelize_lines(osm_woodlands, 700, mindist=350) \nsamples &lt;- lines_center(lixels)\n\n\ndensities.origin &lt;- nkde(osm_woodlands,\n                         events=origin_df.woodlands,\n                         w=rep(1, nrow(origin_df.woodlands)),\n                         samples=samples,\n                         kernel_name=\"quartic\",\n                         bw=300,\n                         div=\"bw\",\n                         method=\"simple\",\n                         digits=1,\n                         tol=1,\n                         grid_shape=c(1,1),\n                         max_depth=8,\n                         agg=5,\n                         sparse=TRUE,\n                         verbose=FALSE\n) \ndensities.destination &lt;- nkde(osm_woodlands,\n                              events=destination_df.woodlands,\n                              w=rep(1, nrow(destination_df.woodlands)),\n                              samples=samples,\n                              kernel_name=\"quartic\",\n                              bw=300,\n                              div=\"bw\",\n                              method=\"simple\",\n                              digits=1,\n                              tol=1,\n                              grid_shape=c(1,1),\n                              max_depth=8,\n                              agg=5,\n                              sparse=TRUE,                          \n                              verbose=FALSE     \n)\n\n\nsamples$density.origin &lt;- densities.origin*1000 \nsamples$density.destination &lt;- densities.destination*1000 \nlixels$density.origin &lt;- densities.origin*1000 \nlixels$density.destination &lt;- densities.destination*1000\n\n\nOriginDestination\n\n\n\ntm_shape(lixels) + \n  tm_lines(col=\"density.origin\")\n\n\n\n\n\n\n\ntm_shape(lixels) +  \n  tm_lines(col=\"density.destination\")\n\n\n\n\n\n\n\nWe can address two very obvious hotspots. First, the hotspot in the west area.\n\n\n\nIn both the origin and destinations, the area around Marsiling MRT is the most dense - suggesting that there might be a lack of efficient transportation around the area from the station, hence people resulting to using Grab. In the origin, there is another hotspot right below the Woodlands checkpoint, suggesting most people Grab from the checkpoint rather than to, perhaps due to fatigue from working/leisuring in Johor Bahru.\n\n\n\nLastly, there is a hotspot in Central Woodlands. This can obviously be attributed to the MRT station, but we can also deduce that the majority of residents are staying in the central area."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#jurong-east",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#jurong-east",
    "title": "Take-Home Exercise 1",
    "section": "5.5 Jurong East",
    "text": "5.5 Jurong East\nWe will be doing the same data preparation for the jurong east area.\n\nje &lt;- mpsz %&gt;%   \n  filter(PLN_AREA_N==\"JURONG EAST\")  \nje &lt;- st_intersection(je, merged_sg) \nosm_je &lt;- st_intersection(osm_sg, je)  \nosm_je_index &lt;- as.numeric(osm_je$osm_id)  \nosm_je &lt;- osm_sg[osm_sg$osm_id %in% osm_je_index, ]\nplot(osm_je)\n\n\n\n\n\ndestination_df.je = st_intersection(destination_df, je)\norigin_df.je = st_intersection(origin_df, je)\n\n\nOriginDestination\n\n\n\ntm_shape(osm_je) +   \n  tm_lines() +\ntm_shape(origin_df.je) +\n  tm_dots(col = \"orange\")\n\n\n\n\n\n\n\ntm_shape(osm_je) +\n  tm_lines() +\ntm_shape(destination_df.je) +\n  tm_dots(col = \"orange\")\n\n\n\n\n\n\n\n\nNKDE Calculation\n\nlixels &lt;- lixelize_lines(osm_je, 700, mindist=350)\nsamples &lt;- lines_center(lixels)\n\n\ndensities.origin &lt;- nkde(osm_je,\n                         events=origin_df.je,\n                         w=rep(1, nrow(origin_df.je)),\n                         samples=samples,\n                         kernel_name=\"quartic\",\n                         bw=300, \n                         div=\"bw\",   \n                         method=\"simple\",  \n                         digits=1,          \n                         tol=1,           \n                         grid_shape=c(1,1),  \n                         max_depth=8,     \n                         agg=5,            \n                         sparse=TRUE,   \n                         verbose=FALSE \n)\ndensities.destination &lt;- nkde(osm_je,\n                              events=destination_df.je,\n                              w=rep(1, nrow(destination_df.je)),\n                              samples=samples,              \n                              kernel_name=\"quartic\",       \n                              bw=300,                     \n                              div=\"bw\",              \n                              method=\"simple\",    \n                              digits=1,        \n                              tol=1,          \n                              grid_shape=c(1,1),       \n                              max_depth=8,           \n                              agg=5,               \n                              sparse=TRUE,   \n                              verbose=FALSE  \n)\n\n\nsamples$density.origin &lt;- densities.origin*1000\nsamples$density.destination &lt;- densities.destination*1000 \nlixels$density.origin &lt;- densities.origin*1000 \nlixels$density.destination &lt;- densities.destination*1000\n\n\nOriginDestination\n\n\n\ntm_shape(lixels) +\n  tm_lines(col=\"density.origin\")\n\n\n\n\n\n\n\ntm_shape(lixels) +  \n  tm_lines(col=\"density.destination\")\n\n\n\n\n\n\n\n\nWith reference to the above image, there are two main areas of interest. The first is on the extreme north-east of the region, where IMM is situated. Being the largest outlet mall in Singapore, it is no surprise that there is a hotspot around this area, with shoppers grabbing to and fro.\nThe other is along Jurong Town Hall Road. My initial suspicions of office complexes was wrong - the two junctions that intersect it on the map that are hotspots both have little to no office buildings, and are mostly residential - specifically, there were a lot of condominium complexes. A possibility for the high amounts of trips originating and ending along this stretch could be due to a lack of efficient public transport around the area, or simply a high concentration of Jurong East residents staying in the area."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#tnkde",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#tnkde",
    "title": "Take-Home Exercise 1",
    "section": "6.0 TNKDE",
    "text": "6.0 TNKDE\nI will also be using TNKDE in order to observe how the density of events changes over time - in the context of this exercise, it will be to analyze the density of pickups/dropoffs at different times of the day on a road network. I referred to this documentation to assist me along the way.\n\n6.1 Changi Airport\n\ndestination_df.changi$end_hr &lt;- as.numeric(destination_df.changi$end_hr)\norigin_df.changi$start_hr &lt;- as.numeric(origin_df.changi$start_hr)\n\n\nlixels &lt;- lixelize_lines(osm_changi, 700, mindist = 350)\nsample_points &lt;- lines_center(lixels)\n\nsample_time.destination &lt;- seq(min(destination_df.changi$end_hr), max(destination_df.changi$end_hr), 1)\nsample_time.origin &lt;- seq(min(origin_df.changi$start_hr), max(origin_df.changi$start_hr), 1)\n\ntnkde_densities.destination &lt;- tnkde(lines = osm_changi,\n                   events = destination_df.changi,\n                   time_field = \"end_hr\",\n                   w = rep(1, nrow(destination_df.changi)), \n                   samples_loc = sample_points,\n                   samples_time = sample_time.destination, \n                   kernel_name = \"quartic\",\n                   bw_net = 300, bw_time = 1,\n                   adaptive = TRUE,\n                   trim_bw_net = 900,\n                   trim_bw_time = 80,\n                   method = \"discontinuous\",\n                   div = \"bw\", max_depth = 10,\n                   digits = 2, tol = 0.01,\n                   agg = 15, grid_shape = c(1,1), \n                   verbose  = FALSE)\n\ntnkde_densities.origin &lt;- tnkde(lines = osm_changi,\n                   events = origin_df.changi,\n                   time_field = \"start_hr\",\n                   w = rep(1, nrow(origin_df.changi)), \n                   samples_loc = sample_points,\n                   samples_time = sample_time.origin, \n                   kernel_name = \"quartic\",\n                   bw_net = 300, bw_time = 1,\n                   adaptive = TRUE,\n                   trim_bw_net = 900,\n                   trim_bw_time = 80,\n                   method = \"discontinuous\",\n                   div = \"bw\", max_depth = 10,\n                   digits = 2, tol = 0.01,\n                   agg = 15, grid_shape = c(1,1), \n                   verbose  = FALSE)\n\nall_densities.destination &lt;- c(tnkde_densities.destination$k)\ncolor_breaks &lt;- classIntervals(all_densities.destination, n = 10, style = \"kmeans\")\n\nall_maps.destination &lt;- lapply(1:ncol(tnkde_densities.destination$k), function(i){\n  time &lt;- sample_time.destination[[i]]\n  sample_points$density &lt;- tnkde_densities.destination$k[,i]\n  map1 &lt;- tm_shape(sample_points) + \n  tm_dots(col = \"density\", size = 0.01,\n          breaks = color_breaks$brks, palette = viridis(10)) + \n    tm_layout(legend.show=FALSE, main.title = paste(\"TNKDE Destination Changi\", time, \":00\"), main.title.size = 0.5)\n  return(map1)\n})\n\ntmap_animation(all_maps.destination, filename = \"images/tnkde_destination_changi.gif\", \n               width = 1000, height = 1000, dpi = 300, delay = 50)\n\nall_densities.origin &lt;- c(tnkde_densities.origin$k)\ncolor_breaks.origin &lt;- classIntervals(all_densities.origin, n = 10, style = \"kmeans\")\n\nall_maps.origin&lt;- lapply(1:ncol(tnkde_densities.origin$k), function(i){\n  time &lt;- sample_time.origin[[i]]\n  \n  sample_points$density &lt;- tnkde_densities.origin$k[,i]\n  map1 &lt;- tm_shape(sample_points) + \n  tm_dots(col = \"density\", size = 0.01,\n          breaks = color_breaks.origin$brks, palette = viridis(10)) + \n    tm_layout(legend.show=FALSE, main.title = paste(\"TNKDE Origin Changi\", time, \":00\"), main.title.size = 0.5)\n  return(map1)\n})\n\ntmap_animation(all_maps.origin, filename = \"images/tnkde_origin_changi.gif\", \n               width = 1000, height = 1000, dpi = 300, delay = 50)\n\n\nOriginDestination\n\n\n\n\n\n\n\n\n\nFrom the TNKDE, we are able to make a few interesting observations. While it is expected that the hours between 12-6 were quiet (as people typically would not want land in the middle of the night), we can observe that the morning hours also had lesser trips from the airport. This could also indicate a preference not to land in the morning - which is something I didn’t expect. However, for the destination, we can observe that it is consistently busy throughout 24 hours.\n\n\n6.2 CBD\n\ndestination_df.cbd$end_hr &lt;- as.numeric(destination_df.cbd$end_hr) \norigin_df.cbd$start_hr &lt;- as.numeric(origin_df.cbd$start_hr)\n\n\nlixels &lt;- lixelize_lines(osm_cbd, 700, mindist = 350)\nsample_points &lt;- lines_center(lixels)\n\nsample_time.destination &lt;- seq(min(destination_df.cbd$end_hr), max(destination_df.cbd$end_hr), 1)\nsample_time.origin &lt;- seq(min(origin_df.cbd$start_hr), max(origin_df.cbd$start_hr), 1)\n\ntnkde_densities.destination &lt;- tnkde(lines = osm_cbd,\n                   events = destination_df.cbd,\n                   time_field = \"end_hr\",\n                   w = rep(1, nrow(destination_df.cbd)), \n                   samples_loc = sample_points,\n                   samples_time = sample_time.destination, \n                   kernel_name = \"quartic\",\n                   bw_net = 300, bw_time = 1,\n                   adaptive = TRUE,\n                   trim_bw_net = 900,\n                   trim_bw_time = 80,\n                   method = \"discontinuous\",\n                   div = \"bw\", max_depth = 10,\n                   digits = 2, tol = 0.01,\n                   agg = 15, grid_shape = c(1,1), \n                   verbose  = FALSE)\n\ntnkde_densities.origin &lt;- tnkde(lines = osm_cbd,\n                   events = origin_df.cbd,\n                   time_field = \"start_hr\",\n                   w = rep(1, nrow(origin_df.cbd)), \n                   samples_loc = sample_points,\n                   samples_time = sample_time.origin, \n                   kernel_name = \"quartic\",\n                   bw_net = 300, bw_time = 1,\n                   adaptive = TRUE,\n                   trim_bw_net = 900,\n                   trim_bw_time = 80,\n                   method = \"discontinuous\",\n                   div = \"bw\", max_depth = 10,\n                   digits = 2, tol = 0.01,\n                   agg = 15, grid_shape = c(1,1), \n                   verbose  = FALSE)\n\nall_densities.destination &lt;- c(tnkde_densities.destination$k)\ncolor_breaks &lt;- classIntervals(all_densities.destination, n = 10, style = \"kmeans\")\n\nall_maps.destination &lt;- lapply(1:ncol(tnkde_densities.destination$k), function(i){\n  time &lt;- sample_time.destination[[i]]\n  sample_points$density &lt;- tnkde_densities.destination$k[,i]\n  map1 &lt;- tm_shape(sample_points) + \n  tm_dots(col = \"density\", size = 0.01,\n          breaks = color_breaks$brks, palette = viridis(10)) + \n    tm_layout(legend.show=FALSE, main.title = paste(\"TNKDE Destination CBD\", time, \":00\"), main.title.size = 0.5)\n  return(map1)\n})\n\ntmap_animation(all_maps.destination, filename = \"images/tnkde_destination_cbd.gif\", \n               width = 1000, height = 1000, dpi = 300, delay = 50)\n\nall_densities.origin &lt;- c(tnkde_densities.origin$k)\ncolor_breaks.origin &lt;- classIntervals(all_densities.origin, n = 10, style = \"kmeans\")\n\nall_maps.origin&lt;- lapply(1:ncol(tnkde_densities.origin$k), function(i){\n  time &lt;- sample_time.origin[[i]]\n  \n  sample_points$density &lt;- tnkde_densities.origin$k[,i]\n  map1 &lt;- tm_shape(sample_points) + \n  tm_dots(col = \"density\", size = 0.01,\n          breaks = color_breaks.origin$brks, palette = viridis(10)) + \n    tm_layout(legend.show=FALSE, main.title = paste(\"TNKDE Origin CBD\", time, \":00\"), main.title.size = 0.5)\n  return(map1)\n})\n\ntmap_animation(all_maps.origin, filename = \"images/tnkde_origin_cbd.gif\", \n               width = 1000, height = 1000, dpi = 300, delay = 50)\n\n\nOriginDestination\n\n\n\n\n\n\n\n\n\nFrom the origin, we see what is expected - the density is highest during the afternoon, but there is an interesting upsurge in traffic around 1am. Similarly, for the destination, density is surprisingly high in the middle of the night (2-4am). This could possibly be due to nightlife activities or some public events/gatherings.\n\n\n6.3 Woodlands\n\ndestination_df.woodlands$end_hr &lt;- as.numeric(destination_df.woodlands$end_hr) \norigin_df.woodlands$start_hr &lt;- as.numeric(origin_df.woodlands$start_hr)\n\n\nlixels &lt;- lixelize_lines(osm_woodlands, 700, mindist = 350)\nsample_points &lt;- lines_center(lixels)\n\nsample_time.destination &lt;- seq(min(destination_df.woodlands$end_hr), max(destination_df.woodlands$end_hr), 1)\nsample_time.origin &lt;- seq(min(origin_df.woodlands$start_hr), max(origin_df.woodlands$start_hr), 1)\n\ntnkde_densities.destination &lt;- tnkde(lines = osm_woodlands,\n                   events = destination_df.woodlands,\n                   time_field = \"end_hr\",\n                   w = rep(1, nrow(destination_df.woodlands)), \n                   samples_loc = sample_points,\n                   samples_time = sample_time.destination, \n                   kernel_name = \"quartic\",\n                   bw_net = 300, bw_time = 1,\n                   adaptive = TRUE,\n                   trim_bw_net = 900,\n                   trim_bw_time = 80,\n                   method = \"discontinuous\",\n                   div = \"bw\", max_depth = 10,\n                   digits = 2, tol = 0.01,\n                   agg = 15, grid_shape = c(1,1), \n                   verbose  = FALSE)\n\ntnkde_densities.origin &lt;- tnkde(lines = osm_woodlands,\n                   events = origin_df.woodlands,\n                   time_field = \"start_hr\",\n                   w = rep(1, nrow(origin_df.woodlands)), \n                   samples_loc = sample_points,\n                   samples_time = sample_time.origin, \n                   kernel_name = \"quartic\",\n                   bw_net = 300, bw_time = 1,\n                   adaptive = TRUE,\n                   trim_bw_net = 900,\n                   trim_bw_time = 80,\n                   method = \"discontinuous\",\n                   div = \"bw\", max_depth = 10,\n                   digits = 2, tol = 0.01,\n                   agg = 15, grid_shape = c(1,1), \n                   verbose  = FALSE)\n\nall_densities.destination &lt;- c(tnkde_densities.destination$k)\ncolor_breaks &lt;- classIntervals(all_densities.destination, n = 10, style = \"kmeans\")\n\nall_maps.destination &lt;- lapply(1:ncol(tnkde_densities.destination$k), function(i){\n  time &lt;- sample_time.destination[[i]]\n  sample_points$density &lt;- tnkde_densities.destination$k[,i]\n  map1 &lt;- tm_shape(sample_points) + \n  tm_dots(col = \"density\", size = 0.01,\n          breaks = color_breaks$brks, palette = viridis(10)) + \n    tm_layout(legend.show=FALSE, main.title = paste(\"TNKDE Destination Woodlands\", time, \":00\"), main.title.size = 0.5)\n  return(map1)\n})\n\ntmap_animation(all_maps.destination, filename = \"images/tnkde_destination_woodlands.gif\", \n               width = 1000, height = 1000, dpi = 300, delay = 50)\n\nCreating frames\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n\nCreating animation\nAnimation saved to C:\\chesterchia\\IS415-GAA\\Take-home_Ex\\Take-home_Ex01\\images\\tnkde_destination_woodlands.gif \n\nall_densities.origin &lt;- c(tnkde_densities.origin$k)\ncolor_breaks.origin &lt;- classIntervals(all_densities.origin, n = 10, style = \"kmeans\")\n\nall_maps.origin&lt;- lapply(1:ncol(tnkde_densities.origin$k), function(i){\n  time &lt;- sample_time.origin[[i]]\n  \n  sample_points$density &lt;- tnkde_densities.origin$k[,i]\n  map1 &lt;- tm_shape(sample_points) + \n  tm_dots(col = \"density\", size = 0.01,\n          breaks = color_breaks.origin$brks, palette = viridis(10)) + \n    tm_layout(legend.show=FALSE, main.title = paste(\"TNKDE Origin Woodlands\", time, \":00\"), main.title.size = 0.5)\n  return(map1)\n})\n\ntmap_animation(all_maps.origin, filename = \"images/tnkde_origin_woodlands.gif\", \n               width = 1000, height = 1000, dpi = 300, delay = 50)\n\nCreating frames\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n\nCreating animation\nAnimation saved to C:\\chesterchia\\IS415-GAA\\Take-home_Ex\\Take-home_Ex01\\images\\tnkde_origin_woodlands.gif \n\n\n\nOriginDestination\n\n\n\n\n\n\n\n\n\nFor Woodlands, there seems to be nothing out of the ordinary. Origin trips are relatively consistent - low in the night, high early in the morning due to people leaving for work. Destination trips are pretty consistent as well, highest during peak hours.\n\n\n6.4 Jurong East\n\ndestination_df.je$end_hr &lt;- as.numeric(destination_df.je$end_hr) \norigin_df.je$start_hr &lt;- as.numeric(origin_df.je$start_hr)\n\n\nlixels &lt;- lixelize_lines(osm_je, 700, mindist = 350)\nsample_points &lt;- lines_center(lixels)\n\nsample_time.destination &lt;- seq(min(destination_df.je$end_hr), max(destination_df.je$end_hr), 1)\nsample_time.origin &lt;- seq(min(origin_df.je$start_hr), max(origin_df.je$start_hr), 1)\n\ntnkde_densities.destination &lt;- tnkde(lines = osm_je,\n                   events = destination_df.je,\n                   time_field = \"end_hr\",\n                   w = rep(1, nrow(destination_df.je)), \n                   samples_loc = sample_points,\n                   samples_time = sample_time.destination, \n                   kernel_name = \"quartic\",\n                   bw_net = 300, bw_time = 1,\n                   adaptive = TRUE,\n                   trim_bw_net = 900,\n                   trim_bw_time = 80,\n                   method = \"discontinuous\",\n                   div = \"bw\", max_depth = 10,\n                   digits = 2, tol = 0.01,\n                   agg = 15, grid_shape = c(1,1), \n                   verbose  = FALSE)\n\ntnkde_densities.origin &lt;- tnkde(lines = osm_je,\n                   events = origin_df.je,\n                   time_field = \"start_hr\",\n                   w = rep(1, nrow(origin_df.je)), \n                   samples_loc = sample_points,\n                   samples_time = sample_time.origin, \n                   kernel_name = \"quartic\",\n                   bw_net = 300, bw_time = 1,\n                   adaptive = TRUE,\n                   trim_bw_net = 900,\n                   trim_bw_time = 80,\n                   method = \"discontinuous\",\n                   div = \"bw\", max_depth = 10,\n                   digits = 2, tol = 0.01,\n                   agg = 15, grid_shape = c(1,1), \n                   verbose  = FALSE)\n\nall_densities.destination &lt;- c(tnkde_densities.destination$k)\ncolor_breaks &lt;- classIntervals(all_densities.destination, n = 10, style = \"kmeans\")\n\nall_maps.destination &lt;- lapply(1:ncol(tnkde_densities.destination$k), function(i){\n  time &lt;- sample_time.destination[[i]]\n  sample_points$density &lt;- tnkde_densities.destination$k[,i]\n  map1 &lt;- tm_shape(sample_points) + \n  tm_dots(col = \"density\", size = 0.01,\n          breaks = color_breaks$brks, palette = viridis(10)) + \n    tm_layout(legend.show=FALSE, main.title = paste(\"TNKDE Destination Jurong East\", time, \":00\"), main.title.size = 0.5)\n  return(map1)\n})\n\ntmap_animation(all_maps.destination, filename = \"images/tnkde_destination_je.gif\", \n               width = 1000, height = 1000, dpi = 300, delay = 50)\n\nCreating frames\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n\nCreating animation\nAnimation saved to C:\\chesterchia\\IS415-GAA\\Take-home_Ex\\Take-home_Ex01\\images\\tnkde_destination_je.gif \n\nall_densities.origin &lt;- c(tnkde_densities.origin$k)\ncolor_breaks.origin &lt;- classIntervals(all_densities.origin, n = 10, style = \"kmeans\")\n\nall_maps.origin&lt;- lapply(1:ncol(tnkde_densities.origin$k), function(i){\n  time &lt;- sample_time.origin[[i]]\n  \n  sample_points$density &lt;- tnkde_densities.origin$k[,i]\n  map1 &lt;- tm_shape(sample_points) + \n  tm_dots(col = \"density\", size = 0.01,\n          breaks = color_breaks.origin$brks, palette = viridis(10)) + \n    tm_layout(legend.show=FALSE, main.title = paste(\"TNKDE Origin Jurong East\", time, \":00\"), main.title.size = 0.5)\n  return(map1)\n})\n\ntmap_animation(all_maps.origin, filename = \"images/tnkde_origin_je.gif\", \n               width = 1000, height = 1000, dpi = 300, delay = 50)\n\nCreating frames\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n===\n\n\n====\n\n\n===\n\n\n\nCreating animation\nAnimation saved to C:\\chesterchia\\IS415-GAA\\Take-home_Ex\\Take-home_Ex01\\images\\tnkde_origin_je.gif \n\n\n\nOriginDestination\n\n\n\n\n\n\n\n\n\nInterestingly in Jurong East, most of the origin trips occur between after midnight and early morning. It is also much more spread out across the whole area, as compared to the destination trips which seem to cluster mainly in the northern area along the main roads. This pattern could indicate that perhaps those trips originating from Jurong East could be night shift workers, while those trips arriving at Jurong East are residents of the estate."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#conclusions",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#conclusions",
    "title": "Take-Home Exercise 1",
    "section": "7.0 Conclusions",
    "text": "7.0 Conclusions\nThe comprehensive analysis of grab patterns in Singapore, with a focus on the hotspots such as Changi, Downtown, Woodlands and Jurong East, has provided valuable insights into the spatio-temporal dynamics of transportation within the city. Leveraging data from Grab, Land Transport Authority (LTA) DataMall, and OpenStreetMap, we applied advanced geospatial analytics techniques to uncover meaningful patterns and trends.\nAdditionally, the integration of network-based kernel density estimation (NKDE) and temporal network kernel density estimation (TNKDE) allowed for a nuanced exploration of spatial and spatio-temporal density distributions. These methods proved effective in capturing localized patterns and temporal variations in taxi demand, providing a more granular understanding of mobility dynamics.\nAs urban landscapes continue to evolve, the application of geospatial analytics to human mobility data becomes increasingly critical. The findings from this project contribute to the broader discourse on smart city planning and underscore the potential of leveraging Information and Communication Technologies (ICT) data for more efficient and sustainable urban transportation systems."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#takeaways",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#takeaways",
    "title": "Take-Home Exercise 1",
    "section": "8.0 Takeaways",
    "text": "8.0 Takeaways\nThis initial take-home exercise proved to be an eye opener for me on multiple fronts. As someone unfamiliar with R programming, the syntax initially posed a challenge to comprehend. Surprisingly, the complexity of the assignment exceeded my expectations for a first task. However, instead of finding it mundane, I was pleasantly surprised by the engaging nature of the exercise. It turned out to be an enjoyable learning experience, prompting me to adapt and be resourceful in my problem-solving approach. Unlike my usual reliance on past exercises or slides, this module encouraged me to explore documentation and broaden my understanding. Completing this exercise has significantly bolstered my confidence in geospatial analytics. I eagerly look forward to the next take-home exercise, hoping for an even more enjoyable and intriguing challenge!"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html",
    "title": "Hands-on_Ex05: Global and Local Measures of Spatial Autocorrelation",
    "section": "",
    "text": "Two data sets will be used in this hands-on exercise, they are:\n\nHunan province administrative boundary layer at county level. This is a geospatial data set in ESRI shapefile format.\nHunan_2012.csv: This csv file contains selected Hunan’s local development indicators in 2012.\n\n\npacman::p_load(sf, spdep, tmap, tidyverse)\n\n\nhunan &lt;- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n\nReading layer `Hunan' from data source \n  `C:\\chesterchia\\IS415-GAA\\Hands-on_Ex\\Hands-on_Ex05\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\nhunan2012 &lt;- read_csv(\"data/aspatial/Hunan_2012.csv\")\n\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nhunan &lt;- left_join(hunan,hunan2012) %&gt;%\n  select(1:4, 7, 15)\n\nJoining with `by = join_by(County)`\n\n\nNow, we are going to prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using qtm() of tmap package.\n\nequal &lt;- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\")\n\nquantile &lt;- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\")\n\ntmap_arrange(equal, \n             quantile, \n             asp=1, \n             ncol=2)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#setup",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#setup",
    "title": "Hands-on_Ex05: Global and Local Measures of Spatial Autocorrelation",
    "section": "",
    "text": "Two data sets will be used in this hands-on exercise, they are:\n\nHunan province administrative boundary layer at county level. This is a geospatial data set in ESRI shapefile format.\nHunan_2012.csv: This csv file contains selected Hunan’s local development indicators in 2012.\n\n\npacman::p_load(sf, spdep, tmap, tidyverse)\n\n\nhunan &lt;- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n\nReading layer `Hunan' from data source \n  `C:\\chesterchia\\IS415-GAA\\Hands-on_Ex\\Hands-on_Ex05\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\nhunan2012 &lt;- read_csv(\"data/aspatial/Hunan_2012.csv\")\n\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nhunan &lt;- left_join(hunan,hunan2012) %&gt;%\n  select(1:4, 7, 15)\n\nJoining with `by = join_by(County)`\n\n\nNow, we are going to prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using qtm() of tmap package.\n\nequal &lt;- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\")\n\nquantile &lt;- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\")\n\ntmap_arrange(equal, \n             quantile, \n             asp=1, \n             ncol=2)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#global-measures-of-spatial-autocorrelation",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#global-measures-of-spatial-autocorrelation",
    "title": "Hands-on_Ex05: Global and Local Measures of Spatial Autocorrelation",
    "section": "2.0 Global Measures of Spatial Autocorrelation",
    "text": "2.0 Global Measures of Spatial Autocorrelation\n\n2.1 Computing Contiguity Spatial Weights\nBefore we can compute the global spatial autocorrelation statistics, we need to construct a spatial weights of the study area. The spatial weights is used to define the neighbourhood relationships between the geographical units (i.e. county) in the study area.\n\nwm_q &lt;- poly2nb(hunan, \n                queen=TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\n\n\n2.2 Row-standardised weights matrix\n\nThe input of nb2listw() must be an object of class nb. The syntax of the function has two major arguments, namely style and zero.poly.\nstyle can take values “W”, “B”, “C”, “U”, “minmax” and “S”. B is the basic binary coding, W is row standardised (sums over all links to n), C is globally standardised (sums over all links to n), U is equal to C divided by the number of neighbours (sums over all links to unity), while S is the variance-stabilizing coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168 (sums over all links to n).\nIf zero policy is set to TRUE, weights vectors of zero length are inserted for regions without neighbour in the neighbours list. These will in turn generate lag values of zero, equivalent to the sum of products of the zero row t(rep(0, length=length(neighbours))) %*% x, for arbitrary numerical vector x of length length(neighbours). The spatially lagged value of x for the zero-neighbour region will then be zero, which may (or may not) be a sensible choice.\n\n\nrswm_q &lt;- nb2listw(wm_q, \n                   style=\"W\", \n                   zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\n\n\n2.3 Moran’s I\nMoran’s I test can be computed using moran.test() of spdep\n\nmoran.test(hunan$GDPPC, \n           listw=rswm_q, \n           zero.policy = TRUE, \n           na.action=na.omit)\n\n\n    Moran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n\n\nWe can compute Monte Carlo Moran’s I using moran.mc(), performing 1000 simulations.\n\nset.seed(1234)\nbperm= moran.mc(hunan$GDPPC, \n                listw=rswm_q, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nVisualisation:\n\nmean(bperm$res[1:999])\n\n[1] -0.01504572\n\n\n\nvar(bperm$res[1:999])\n\n[1] 0.004371574\n\n\n\nsummary(bperm$res[1:999])\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n\n\n\nhist(bperm$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I\")\nabline(v=0, \n       col=\"red\") \n\n\n\n\n\n\n2.4 Geary’s C\nWe can also perform Geary’s C test for spatial autocorrelation using geary.test() of spdep\n\ngeary.test(hunan$GDPPC, listw=rswm_q)\n\n\n    Geary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n\n\nComputing Monte Carlo’s Geary C using geary.mc()\n\nset.seed(1234)\nbperm=geary.mc(hunan$GDPPC, \n               listw=rswm_q, \n               nsim=999)\nbperm\n\n\n    Monte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n\n\nVisualisation:\n\nmean(bperm$res[1:999])\n\n[1] 1.004402\n\n\n\nvar(bperm$res[1:999])\n\n[1] 0.007436493\n\n\n\nsummary(bperm$res[1:999])\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7142  0.9502  1.0052  1.0044  1.0595  1.2722 \n\n\n\nhist(bperm$res, freq=TRUE, breaks=20, xlab=\"Simulated Geary c\")\nabline(v=1, col=\"red\") \n\n\n\n\n\n\n2.5 Spatial Correlogram\nSpatial correlograms are great to examine patterns of spatial autocorrelation in your data or model residuals. They show how correlated are pairs of spatial observations when you increase the distance (lag) between them - they are plots of some index of autocorrelation (Moran’s I or Geary’s c) against distance.Although correlograms are not as fundamental as variograms (a keystone concept of geostatistics), they are very useful as an exploratory and descriptive tool. For this purpose they actually provide richer information than variograms.\nMoran I’s correlogram can be computed using sp.correlogram()\n\nMI_corr &lt;- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"I\", \n                          style=\"W\")\nplot(MI_corr)\n\n\n\n\n\nprint(MI_corr)\n\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nWe can use sp.correlogram() for Geary’s C as well\n\nGC_corr &lt;- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"C\", \n                          style=\"W\")\nplot(GC_corr)\n\n\n\n\n\nprint(GC_corr)\n\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#local-measures-of-spatial-autocorrelation",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#local-measures-of-spatial-autocorrelation",
    "title": "Hands-on_Ex05: Global and Local Measures of Spatial Autocorrelation",
    "section": "3.0 Local Measures of Spatial Autocorrelation",
    "text": "3.0 Local Measures of Spatial Autocorrelation\n\n3.1 Compute local Moran’s I\nTo compute local Moran’s I, we can use localmoran() of spdep\n\nfips &lt;- order(hunan$County)\nlocalMI &lt;- localmoran(hunan$GDPPC, rswm_q)\nhead(localMI)\n\n            Ii          E.Ii       Var.Ii        Z.Ii Pr(z != E(Ii))\n1 -0.001468468 -2.815006e-05 4.723841e-04 -0.06626904      0.9471636\n2  0.025878173 -6.061953e-04 1.016664e-02  0.26266425      0.7928094\n3 -0.011987646 -5.366648e-03 1.133362e-01 -0.01966705      0.9843090\n4  0.001022468 -2.404783e-07 5.105969e-06  0.45259801      0.6508382\n5  0.014814881 -6.829362e-05 1.449949e-03  0.39085814      0.6959021\n6 -0.038793829 -3.860263e-04 6.475559e-03 -0.47728835      0.6331568\n\n\nlocalmoran() function returns a matrix of values whose columns are:\n\nIi: the local Moran’s I statistics\nE.Ii: the expectation of local moran statistic under the randomisation hypothesis\nVar.Ii: the variance of local moran statistic under the randomisation hypothesis\nZ.Ii:the standard deviate of local moran statistic\nPr(): the p-value of local moran statistic\n\n\nprintCoefmat(data.frame(\n  localMI[fips,], \n  row.names=hunan$County[fips]),\n  check.names=FALSE)\n\n                       Ii        E.Ii      Var.Ii        Z.Ii Pr.z....E.Ii..\nAnhua         -2.2493e-02 -5.0048e-03  5.8235e-02 -7.2467e-02         0.9422\nAnren         -3.9932e-01 -7.0111e-03  7.0348e-02 -1.4791e+00         0.1391\nAnxiang       -1.4685e-03 -2.8150e-05  4.7238e-04 -6.6269e-02         0.9472\nBaojing        3.4737e-01 -5.0089e-03  8.3636e-02  1.2185e+00         0.2230\nChaling        2.0559e-02 -9.6812e-04  2.7711e-02  1.2932e-01         0.8971\nChangning     -2.9868e-05 -9.0010e-09  1.5105e-07 -7.6828e-02         0.9388\nChangsha       4.9022e+00 -2.1348e-01  2.3194e+00  3.3590e+00         0.0008\nChengbu        7.3725e-01 -1.0534e-02  2.2132e-01  1.5895e+00         0.1119\nChenxi         1.4544e-01 -2.8156e-03  4.7116e-02  6.8299e-01         0.4946\nCili           7.3176e-02 -1.6747e-03  4.7902e-02  3.4200e-01         0.7324\nDao            2.1420e-01 -2.0824e-03  4.4123e-02  1.0297e+00         0.3032\nDongan         1.5210e-01 -6.3485e-04  1.3471e-02  1.3159e+00         0.1882\nDongkou        5.2918e-01 -6.4461e-03  1.0748e-01  1.6338e+00         0.1023\nFenghuang      1.8013e-01 -6.2832e-03  1.3257e-01  5.1198e-01         0.6087\nGuidong       -5.9160e-01 -1.3086e-02  3.7003e-01 -9.5104e-01         0.3416\nGuiyang        1.8240e-01 -3.6908e-03  3.2610e-02  1.0305e+00         0.3028\nGuzhang        2.8466e-01 -8.5054e-03  1.4152e-01  7.7931e-01         0.4358\nHanshou        2.5878e-02 -6.0620e-04  1.0167e-02  2.6266e-01         0.7928\nHengdong       9.9964e-03 -4.9063e-04  6.7742e-03  1.2742e-01         0.8986\nHengnan        2.8064e-02 -3.2160e-04  3.7597e-03  4.6294e-01         0.6434\nHengshan      -5.8201e-03 -3.0437e-05  5.1076e-04 -2.5618e-01         0.7978\nHengyang       6.2997e-02 -1.3046e-03  2.1865e-02  4.3486e-01         0.6637\nHongjiang      1.8790e-01 -2.3019e-03  3.1725e-02  1.0678e+00         0.2856\nHuarong       -1.5389e-02 -1.8667e-03  8.1030e-02 -4.7503e-02         0.9621\nHuayuan        8.3772e-02 -8.5569e-04  2.4495e-02  5.4072e-01         0.5887\nHuitong        2.5997e-01 -5.2447e-03  1.1077e-01  7.9685e-01         0.4255\nJiahe         -1.2431e-01 -3.0550e-03  5.1111e-02 -5.3633e-01         0.5917\nJianghua       2.8651e-01 -3.8280e-03  8.0968e-02  1.0204e+00         0.3076\nJiangyong      2.4337e-01 -2.7082e-03  1.1746e-01  7.1800e-01         0.4728\nJingzhou       1.8270e-01 -8.5106e-04  2.4363e-02  1.1759e+00         0.2396\nJinshi        -1.1988e-02 -5.3666e-03  1.1334e-01 -1.9667e-02         0.9843\nJishou        -2.8680e-01 -2.6305e-03  4.4028e-02 -1.3543e+00         0.1756\nLanshan        6.3334e-02 -9.6365e-04  2.0441e-02  4.4972e-01         0.6529\nLeiyang        1.1581e-02 -1.4948e-04  2.5082e-03  2.3422e-01         0.8148\nLengshuijiang -1.7903e+00 -8.2129e-02  2.1598e+00 -1.1623e+00         0.2451\nLi             1.0225e-03 -2.4048e-07  5.1060e-06  4.5260e-01         0.6508\nLianyuan      -1.4672e-01 -1.8983e-03  1.9145e-02 -1.0467e+00         0.2952\nLiling         1.3774e+00 -1.5097e-02  4.2601e-01  2.1335e+00         0.0329\nLinli          1.4815e-02 -6.8294e-05  1.4499e-03  3.9086e-01         0.6959\nLinwu         -2.4621e-03 -9.0703e-06  1.9258e-04 -1.7676e-01         0.8597\nLinxiang       6.5904e-02 -2.9028e-03  2.5470e-01  1.3634e-01         0.8916\nLiuyang        3.3688e+00 -7.7502e-02  1.5180e+00  2.7972e+00         0.0052\nLonghui        8.0801e-01 -1.1377e-02  1.5538e-01  2.0787e+00         0.0376\nLongshan       7.5663e-01 -1.1100e-02  3.1449e-01  1.3690e+00         0.1710\nLuxi           1.8177e-01 -2.4855e-03  3.4249e-02  9.9561e-01         0.3194\nMayang         2.1852e-01 -5.8773e-03  9.8049e-02  7.1663e-01         0.4736\nMiluo          1.8704e+00 -1.6927e-02  2.7925e-01  3.5715e+00         0.0004\nNan           -9.5789e-03 -4.9497e-04  6.8341e-03 -1.0988e-01         0.9125\nNingxiang      1.5607e+00 -7.3878e-02  8.0012e-01  1.8274e+00         0.0676\nNingyuan       2.0910e-01 -7.0884e-03  8.2306e-02  7.5356e-01         0.4511\nPingjiang     -9.8964e-01 -2.6457e-03  5.6027e-02 -4.1698e+00         0.0000\nQidong         1.1806e-01 -2.1207e-03  2.4747e-02  7.6396e-01         0.4449\nQiyang         6.1966e-02 -7.3374e-04  8.5743e-03  6.7712e-01         0.4983\nRucheng       -3.6992e-01 -8.8999e-03  2.5272e-01 -7.1814e-01         0.4727\nSangzhi        2.5053e-01 -4.9470e-03  6.8000e-02  9.7972e-01         0.3272\nShaodong      -3.2659e-02 -3.6592e-05  5.0546e-04 -1.4510e+00         0.1468\nShaoshan       2.1223e+00 -5.0227e-02  1.3668e+00  1.8583e+00         0.0631\nShaoyang       5.9499e-01 -1.1253e-02  1.3012e-01  1.6807e+00         0.0928\nShimen        -3.8794e-02 -3.8603e-04  6.4756e-03 -4.7729e-01         0.6332\nShuangfeng     9.2835e-03 -2.2867e-03  3.1516e-02  6.5174e-02         0.9480\nShuangpai      8.0591e-02 -3.1366e-04  8.9838e-03  8.5358e-01         0.3933\nSuining        3.7585e-01 -3.5933e-03  4.1870e-02  1.8544e+00         0.0637\nTaojiang      -2.5394e-01 -1.2395e-03  1.4477e-02 -2.1002e+00         0.0357\nTaoyuan        1.4729e-02 -1.2039e-04  8.5103e-04  5.0903e-01         0.6107\nTongdao        4.6482e-01 -6.9870e-03  1.9879e-01  1.0582e+00         0.2900\nWangcheng      4.4220e+00 -1.1067e-01  1.3596e+00  3.8873e+00         0.0001\nWugang         7.1003e-01 -7.8144e-03  1.0710e-01  2.1935e+00         0.0283\nXiangtan       2.4530e-01 -3.6457e-04  3.2319e-03  4.3213e+00         0.0000\nXiangxiang     2.6271e-01 -1.2703e-03  2.1290e-02  1.8092e+00         0.0704\nXiangyin       5.4525e-01 -4.7442e-03  7.9236e-02  1.9539e+00         0.0507\nXinhua         1.1810e-01 -6.2649e-03  8.6001e-02  4.2409e-01         0.6715\nXinhuang       1.5725e-01 -4.1820e-03  3.6648e-01  2.6667e-01         0.7897\nXinning        6.8928e-01 -9.6674e-03  2.0328e-01  1.5502e+00         0.1211\nXinshao        5.7578e-02 -8.5932e-03  1.1769e-01  1.9289e-01         0.8470\nXintian       -7.4050e-03 -5.1493e-03  1.0877e-01 -6.8395e-03         0.9945\nXupu           3.2406e-01 -5.7468e-03  5.7735e-02  1.3726e+00         0.1699\nYanling       -6.9021e-02 -5.9211e-04  9.9306e-03 -6.8667e-01         0.4923\nYizhang       -2.6844e-01 -2.2463e-03  4.7588e-02 -1.2202e+00         0.2224\nYongshun       6.3064e-01 -1.1350e-02  1.8830e-01  1.4795e+00         0.1390\nYongxing       4.3411e-01 -9.0735e-03  1.5088e-01  1.1409e+00         0.2539\nYou            7.8750e-02 -7.2728e-03  1.2116e-01  2.4714e-01         0.8048\nYuanjiang      2.0004e-04 -1.7760e-04  2.9798e-03  6.9181e-03         0.9945\nYuanling       8.7298e-03 -2.2981e-06  2.3221e-05  1.8121e+00         0.0700\nYueyang        4.1189e-02 -1.9768e-04  2.3113e-03  8.6085e-01         0.3893\nZhijiang       1.0476e-01 -7.8123e-04  1.3100e-02  9.2214e-01         0.3565\nZhongfang     -2.2685e-01 -2.1455e-03  3.5927e-02 -1.1855e+00         0.2358\nZhuzhou        3.2864e-01 -5.2432e-04  7.2391e-03  3.8688e+00         0.0001\nZixing        -7.6849e-01 -8.8210e-02  9.4057e-01 -7.0144e-01         0.4830\n\n\nBefore mapping local Moran’s I map, we should append the dataframe onto hunan SpatialPolygonDataFrame.\n\nhunan.localMI &lt;- cbind(hunan,localMI) %&gt;%\n  rename(Pr.Ii = Pr.z....E.Ii..)\n\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\",\n          palette = \"RdBu\",\n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)\n\nVariable(s) \"Ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\nlocalMI.map &lt;- tm_shape(hunan.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\", \n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)\n\npvalue.map &lt;- tm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(localMI.map, pvalue.map, asp=1, ncol=2)\n\nVariable(s) \"Ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\n\n3.2 Creating a LISA Cluster Map\nPlotting moran scatterplot with moran.plot():\n\nnci &lt;- moran.plot(hunan$GDPPC, rswm_q,\n                  labels=as.character(hunan$County), \n                  xlab=\"GDPPC 2012\", \n                  ylab=\"Spatially Lag GDPPC 2012\")\n\n\n\n\nWith standardised variable - will use scale() to center and scale the variable.\n\nhunan$Z.GDPPC &lt;- scale(hunan$GDPPC) %&gt;% \n  as.vector \n\n\nnci2 &lt;- moran.plot(hunan$Z.GDPPC, rswm_q,\n                   labels=as.character(hunan$County),\n                   xlab=\"z-GDPPC 2012\", \n                   ylab=\"Spatially Lag z-GDPPC 2012\")\n\n\n\n\nHere are the steps to prepare a LISA cluster map:\n\nquadrant &lt;- vector(mode=\"numeric\",length=nrow(localMI))\n\nNext, derive spatially lagged variable interest (GDPPC) and center the variable around the mean.\n\nhunan$lag_GDPPC &lt;- lag.listw(rswm_q, hunan$GDPPC)\nDV &lt;- hunan$lag_GDPPC - mean(hunan$lag_GDPPC)     \n\n\nLM_I &lt;- localMI[,1] - mean(localMI[,1])    \n\nSet a statistical significance level:\n\nsignif &lt;- 0.05       \n\nDefine low-low, low-high, high-low, high-high:\n\nquadrant[DV &lt;0 & LM_I&gt;0] &lt;- 1\nquadrant[DV &gt;0 & LM_I&lt;0] &lt;- 2\nquadrant[DV &lt;0 & LM_I&lt;0] &lt;- 3  \nquadrant[DV &gt;0 & LM_I&gt;0] &lt;- 4      \n\nPlace non-significant Moran in category 0:\n\nquadrant[localMI[,5]&gt;signif] &lt;- 0\n\nPlot the LISA map:\n\nhunan.localMI$quadrant &lt;- quadrant\ncolors &lt;- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters &lt;- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5)\n\n\n\n\nFor effective interpretation, it is better to plot both the local Moran’s I values map and its corresponding p-values map next to each other.\n\ngdppc &lt;- qtm(hunan, \"GDPPC\")\n\nhunan.localMI$quadrant &lt;- quadrant\ncolors &lt;- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters &lt;- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\nLISAmap &lt;- tm_shape(hunan.localMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5)\n\ntmap_arrange(gdppc, LISAmap, \n             asp=1, ncol=2)\n\n\n\n\n\n\n3.3 Hot Spot and Cold Spot Area Analysis\nAn alternative spatial statistics to detect spatial anomalies is the Getis and Ord’s G-statistics (Getis and Ord, 1972; Ord and Getis, 1995). It looks at neighbours within a defined proximity to identify where either high or low values clutser spatially. Here, statistically significant hot-spots are recognised as areas of high values where other areas within a neighbourhood range also share high values too.\nThe analysis consists of three steps:\n\nDeriving spatial weight matrix\nComputing Gi statistics\nMapping Gi statistics\n\nFirst, we need to define a new set of neighbours. Whist the spatial autocorrelation considered units which shared borders, for Getis-Ord we are defining neighbours based on distance.\nThere are two type of distance-based proximity matrix, they are:\n\nfixed distance weight matrix; and\nadaptive distance weight matrix.\n\nWe will need points to associate with each polygon before we can make our connectivity graph. It will be a little more complicated than just running st_centroid() on the sf object: us.bound. We need the coordinates in a separate data frame for this to work. To do this we will use a mapping function. The mapping function applies a given function to each element of a vector and returns a vector of the same length. Our input vector will be the geometry column of us.bound. Our function will be st_centroid(). We will be using map_dbl variation of map from the purrr package. For more documentation, check out map documentation\nTo get our longitude values we map the st_centroid() function over the geometry column of us.bound and access the longitude value through double bracket notation [[]] and 1. This allows us to get only the longitude, which is the first value in each centroid.\n\nlongitude &lt;- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n\n\nlatitude &lt;- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\n\ncoords &lt;- cbind(longitude, latitude)\n\nFirstly, we need to determine the upper limit for distance band by using the steps below:\n\nReturn a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using knearneigh() of spdep.\nConvert the knn object returned by knearneigh() into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using knn2nb().\nReturn the length of neighbour relationship edges by using nbdists() of spdep. The function returns in the units of the coordinates if the coordinates are projected, in km otherwise.\nRemove the list structure of the returned object by using unlist().\n\n\n#coords &lt;- coordinates(hunan)\nk1 &lt;- knn2nb(knearneigh(coords))\nk1dists &lt;- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nNow, we will compute the distance weight matrix using dnearneigh()\n\nwm_d62 &lt;- dnearneigh(coords, 0, 62, longlat = TRUE)\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\nNext, nb2listw() is used to convert the nb object into spatial weights object.\n\nwm62_lw &lt;- nb2listw(wm_d62, style = 'B')\nsummary(wm62_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \nLink number distribution:\n\n 1  2  3  4  5  6 \n 6 15 14 26 20  7 \n6 least connected regions:\n6 15 30 32 56 65 with 1 link\n7 most connected regions:\n21 28 35 45 50 52 82 with 6 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1   S2\nB 88 7744 324 648 5440\n\n\nOne of the characteristics of fixed distance weight matrix is that more densely settled areas (usually the urban areas) tend to have more neighbours and the less densely settled areas (usually the rural counties) tend to have lesser neighbours. Having many neighbours smoothes the neighbour relationship across more neighbours.\nIt is possible to control the numbers of neighbours directly using k-nearest neighbours, either accepting asymmetric neighbours or imposing symmetry:\n\nknn &lt;- knn2nb(knearneigh(coords, k=8))\nknn\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\n\n\n\nknn_lw &lt;- nb2listw(knn, style = 'B')\nsummary(knn_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\nLink number distribution:\n\n 8 \n88 \n88 least connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n88 most connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0   S1    S2\nB 88 7744 704 1300 23014\n\n\n\n\n3.4 Computing Gi statistics\n\nfips &lt;- order(hunan$County)\ngi.fixed &lt;- localG(hunan$GDPPC, wm62_lw)\ngi.fixed\n\n [1]  0.436075843 -0.265505650 -0.073033665  0.413017033  0.273070579\n [6] -0.377510776  2.863898821  2.794350420  5.216125401  0.228236603\n[11]  0.951035346 -0.536334231  0.176761556  1.195564020 -0.033020610\n[16]  1.378081093 -0.585756761 -0.419680565  0.258805141  0.012056111\n[21] -0.145716531 -0.027158687 -0.318615290 -0.748946051 -0.961700582\n[26] -0.796851342 -1.033949773 -0.460979158 -0.885240161 -0.266671512\n[31] -0.886168613 -0.855476971 -0.922143185 -1.162328599  0.735582222\n[36] -0.003358489 -0.967459309 -1.259299080 -1.452256513 -1.540671121\n[41] -1.395011407 -1.681505286 -1.314110709 -0.767944457 -0.192889342\n[46]  2.720804542  1.809191360 -1.218469473 -0.511984469 -0.834546363\n[51] -0.908179070 -1.541081516 -1.192199867 -1.075080164 -1.631075961\n[56] -0.743472246  0.418842387  0.832943753 -0.710289083 -0.449718820\n[61] -0.493238743 -1.083386776  0.042979051  0.008596093  0.136337469\n[66]  2.203411744  2.690329952  4.453703219 -0.340842743 -0.129318589\n[71]  0.737806634 -1.246912658  0.666667559  1.088613505 -0.985792573\n[76]  1.233609606 -0.487196415  1.626174042 -1.060416797  0.425361422\n[81] -0.837897118 -0.314565243  0.371456331  4.424392623 -0.109566928\n[86]  1.364597995 -1.029658605 -0.718000620\nattr(,\"internals\")\n               Gi      E(Gi)        V(Gi)        Z(Gi) Pr(z != E(Gi))\n [1,] 0.064192949 0.05747126 2.375922e-04  0.436075843   6.627817e-01\n [2,] 0.042300020 0.04597701 1.917951e-04 -0.265505650   7.906200e-01\n [3,] 0.044961480 0.04597701 1.933486e-04 -0.073033665   9.417793e-01\n [4,] 0.039475779 0.03448276 1.461473e-04  0.413017033   6.795941e-01\n [5,] 0.049767939 0.04597701 1.927263e-04  0.273070579   7.847990e-01\n [6,] 0.008825335 0.01149425 4.998177e-05 -0.377510776   7.057941e-01\n [7,] 0.050807266 0.02298851 9.435398e-05  2.863898821   4.184617e-03\n [8,] 0.083966739 0.04597701 1.848292e-04  2.794350420   5.200409e-03\n [9,] 0.115751554 0.04597701 1.789361e-04  5.216125401   1.827045e-07\n[10,] 0.049115587 0.04597701 1.891013e-04  0.228236603   8.194623e-01\n[11,] 0.045819180 0.03448276 1.420884e-04  0.951035346   3.415864e-01\n[12,] 0.049183846 0.05747126 2.387633e-04 -0.536334231   5.917276e-01\n[13,] 0.048429181 0.04597701 1.924532e-04  0.176761556   8.596957e-01\n[14,] 0.034733752 0.02298851 9.651140e-05  1.195564020   2.318667e-01\n[15,] 0.011262043 0.01149425 4.945294e-05 -0.033020610   9.736582e-01\n[16,] 0.065131196 0.04597701 1.931870e-04  1.378081093   1.681783e-01\n[17,] 0.027587075 0.03448276 1.385862e-04 -0.585756761   5.580390e-01\n[18,] 0.029409313 0.03448276 1.461397e-04 -0.419680565   6.747188e-01\n[19,] 0.061466754 0.05747126 2.383385e-04  0.258805141   7.957856e-01\n[20,] 0.057656917 0.05747126 2.371303e-04  0.012056111   9.903808e-01\n[21,] 0.066518379 0.06896552 2.820326e-04 -0.145716531   8.841452e-01\n[22,] 0.045599896 0.04597701 1.928108e-04 -0.027158687   9.783332e-01\n[23,] 0.030646753 0.03448276 1.449523e-04 -0.318615290   7.500183e-01\n[24,] 0.035635552 0.04597701 1.906613e-04 -0.748946051   4.538897e-01\n[25,] 0.032606647 0.04597701 1.932888e-04 -0.961700582   3.362000e-01\n[26,] 0.035001352 0.04597701 1.897172e-04 -0.796851342   4.255374e-01\n[27,] 0.012746354 0.02298851 9.812587e-05 -1.033949773   3.011596e-01\n[28,] 0.061287917 0.06896552 2.773884e-04 -0.460979158   6.448136e-01\n[29,] 0.014277403 0.02298851 9.683314e-05 -0.885240161   3.760271e-01\n[30,] 0.009622875 0.01149425 4.924586e-05 -0.266671512   7.897221e-01\n[31,] 0.014258398 0.02298851 9.705244e-05 -0.886168613   3.755267e-01\n[32,] 0.005453443 0.01149425 4.986245e-05 -0.855476971   3.922871e-01\n[33,] 0.043283712 0.05747126 2.367109e-04 -0.922143185   3.564539e-01\n[34,] 0.020763514 0.03448276 1.393165e-04 -1.162328599   2.451020e-01\n[35,] 0.081261843 0.06896552 2.794398e-04  0.735582222   4.619850e-01\n[36,] 0.057419907 0.05747126 2.338437e-04 -0.003358489   9.973203e-01\n[37,] 0.013497133 0.02298851 9.624821e-05 -0.967459309   3.333145e-01\n[38,] 0.019289310 0.03448276 1.455643e-04 -1.259299080   2.079223e-01\n[39,] 0.025996272 0.04597701 1.892938e-04 -1.452256513   1.464303e-01\n[40,] 0.016092694 0.03448276 1.424776e-04 -1.540671121   1.233968e-01\n[41,] 0.035952614 0.05747126 2.379439e-04 -1.395011407   1.630124e-01\n[42,] 0.031690963 0.05747126 2.350604e-04 -1.681505286   9.266481e-02\n[43,] 0.018750079 0.03448276 1.433314e-04 -1.314110709   1.888090e-01\n[44,] 0.015449080 0.02298851 9.638666e-05 -0.767944457   4.425202e-01\n[45,] 0.065760689 0.06896552 2.760533e-04 -0.192889342   8.470456e-01\n[46,] 0.098966900 0.05747126 2.326002e-04  2.720804542   6.512325e-03\n[47,] 0.085415780 0.05747126 2.385746e-04  1.809191360   7.042128e-02\n[48,] 0.038816536 0.05747126 2.343951e-04 -1.218469473   2.230456e-01\n[49,] 0.038931873 0.04597701 1.893501e-04 -0.511984469   6.086619e-01\n[50,] 0.055098610 0.06896552 2.760948e-04 -0.834546363   4.039732e-01\n[51,] 0.033405005 0.04597701 1.916312e-04 -0.908179070   3.637836e-01\n[52,] 0.043040784 0.06896552 2.829941e-04 -1.541081516   1.232969e-01\n[53,] 0.011297699 0.02298851 9.615920e-05 -1.192199867   2.331829e-01\n[54,] 0.040968457 0.05747126 2.356318e-04 -1.075080164   2.823388e-01\n[55,] 0.023629663 0.04597701 1.877170e-04 -1.631075961   1.028743e-01\n[56,] 0.006281129 0.01149425 4.916619e-05 -0.743472246   4.571958e-01\n[57,] 0.063918654 0.05747126 2.369553e-04  0.418842387   6.753313e-01\n[58,] 0.070325003 0.05747126 2.381374e-04  0.832943753   4.048765e-01\n[59,] 0.025947288 0.03448276 1.444058e-04 -0.710289083   4.775249e-01\n[60,] 0.039752578 0.04597701 1.915656e-04 -0.449718820   6.529132e-01\n[61,] 0.049934283 0.05747126 2.334965e-04 -0.493238743   6.218439e-01\n[62,] 0.030964195 0.04597701 1.920248e-04 -1.083386776   2.786368e-01\n[63,] 0.058129184 0.05747126 2.343319e-04  0.042979051   9.657182e-01\n[64,] 0.046096514 0.04597701 1.932637e-04  0.008596093   9.931414e-01\n[65,] 0.012459080 0.01149425 5.008051e-05  0.136337469   8.915545e-01\n[66,] 0.091447733 0.05747126 2.377744e-04  2.203411744   2.756574e-02\n[67,] 0.049575872 0.02298851 9.766513e-05  2.690329952   7.138140e-03\n[68,] 0.107907212 0.04597701 1.933581e-04  4.453703219   8.440175e-06\n[69,] 0.019616151 0.02298851 9.789454e-05 -0.340842743   7.332220e-01\n[70,] 0.032923393 0.03448276 1.454032e-04 -0.129318589   8.971056e-01\n[71,] 0.030317663 0.02298851 9.867859e-05  0.737806634   4.606320e-01\n[72,] 0.019437582 0.03448276 1.455870e-04 -1.246912658   2.124295e-01\n[73,] 0.055245460 0.04597701 1.932838e-04  0.666667559   5.049845e-01\n[74,] 0.074278054 0.05747126 2.383538e-04  1.088613505   2.763244e-01\n[75,] 0.013269580 0.02298851 9.719982e-05 -0.985792573   3.242349e-01\n[76,] 0.049407829 0.03448276 1.463785e-04  1.233609606   2.173484e-01\n[77,] 0.028605749 0.03448276 1.455139e-04 -0.487196415   6.261191e-01\n[78,] 0.039087662 0.02298851 9.801040e-05  1.626174042   1.039126e-01\n[79,] 0.031447120 0.04597701 1.877464e-04 -1.060416797   2.889550e-01\n[80,] 0.064005294 0.05747126 2.359641e-04  0.425361422   6.705732e-01\n[81,] 0.044606529 0.05747126 2.357330e-04 -0.837897118   4.020885e-01\n[82,] 0.063700493 0.06896552 2.801427e-04 -0.314565243   7.530918e-01\n[83,] 0.051142205 0.04597701 1.933560e-04  0.371456331   7.102977e-01\n[84,] 0.102121112 0.04597701 1.610278e-04  4.424392623   9.671399e-06\n[85,] 0.021901462 0.02298851 9.843172e-05 -0.109566928   9.127528e-01\n[86,] 0.064931813 0.04597701 1.929430e-04  1.364597995   1.723794e-01\n[87,] 0.031747344 0.04597701 1.909867e-04 -1.029658605   3.031703e-01\n[88,] 0.015893319 0.02298851 9.765131e-05 -0.718000620   4.727569e-01\nattr(,\"cluster\")\n [1] Low  Low  High High High High High High High Low  Low  High Low  Low  Low \n[16] High High High High Low  High High Low  Low  High Low  Low  Low  Low  Low \n[31] Low  Low  Low  High Low  Low  Low  Low  Low  Low  High Low  Low  Low  Low \n[46] High High Low  Low  Low  Low  High Low  Low  Low  Low  Low  High Low  Low \n[61] Low  Low  Low  High High High Low  High Low  Low  High Low  High High Low \n[76] High Low  Low  Low  Low  Low  Low  High High Low  High Low  Low \nLevels: Low High\nattr(,\"gstari\")\n[1] FALSE\nattr(,\"call\")\nlocalG(x = hunan$GDPPC, listw = wm62_lw)\nattr(,\"class\")\n[1] \"localG\"\n\n\nThe output of localG() is a vector of G or Gstar values, with attributes “gstari” set to TRUE or FALSE, “call” set to the function call, and class “localG”.\nThe Gi statistics is represented as a Z-score. Greater values represent a greater intensity of clustering and the direction (positive or negative) indicates high or low clusters.\nNext, we will join the Gi values to their corresponding hunan sf data frame:\n\nhunan.gi &lt;- cbind(hunan, as.matrix(gi.fixed)) %&gt;%\n  rename(gstat_fixed = as.matrix.gi.fixed.)\n\nMapping Gi values with fixed distance weights:\n\ngdppc &lt;- qtm(hunan, \"GDPPC\")\n\nGimap &lt;-tm_shape(hunan.gi) +\n  tm_fill(col = \"gstat_fixed\", \n          style = \"pretty\",\n          palette=\"-RdBu\",\n          title = \"local Gi\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(gdppc, Gimap, asp=1, ncol=2)\n\nVariable(s) \"gstat_fixed\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\nAdaptive distance:\n\nfips &lt;- order(hunan$County)\ngi.adaptive &lt;- localG(hunan$GDPPC, knn_lw)\nhunan.gi &lt;- cbind(hunan, as.matrix(gi.adaptive)) %&gt;%\n  rename(gstat_adaptive = as.matrix.gi.adaptive.)\n\n\ngdppc&lt;- qtm(hunan, \"GDPPC\")\n\nGimap &lt;- tm_shape(hunan.gi) + \n  tm_fill(col = \"gstat_adaptive\", \n          style = \"pretty\", \n          palette=\"-RdBu\", \n          title = \"local Gi\") + \n  tm_borders(alpha = 0.5)\n\ntmap_arrange(gdppc, \n             Gimap, \n             asp=1, \n             ncol=2)\n\nVariable(s) \"gstat_adaptive\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex05/In-class_Ex05.html",
    "href": "In-class_Ex/In-class_Ex05/In-class_Ex05.html",
    "title": "In-class Exercise 5",
    "section": "",
    "text": "Installing and Loading R Packages\n\npacman::p_load(sf, sfdep, tmap, tidyverse)\n\n\n\nImporting geospatial data\n\nhunan &lt;- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n\nReading layer `Hunan' from data source \n  `C:\\chesterchia\\IS415-GAA\\In-class_Ex\\In-class_Ex05\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\nhunan2012 &lt;- read_csv(\"data/aspatial/Hunan_2012.csv\")\n\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\nCombine both data frame using left join\n\nhunan_GDPPC &lt;- left_join(hunan, hunan2012) %&gt;%\n  select(1:4, 7, 15)\n\nJoining with `by = join_by(County)`\n\n\n\n\nPlotting a chloropleth map\n\ntmap_mode(\"plot\")\n\ntmap mode set to plotting\n\ntm_shape(hunan_GDPPC) +\n  tm_fill(\"GDPPC\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"GDPPC\") +\n  tm_layout(main.title = \"Distribution of GDP per capita by district, Hunan Province\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2)\n\n\n\n\n\n\nDeriving contiguity weights: Queen’s method\n\nwm_q &lt;- hunan_GDPPC %&gt;%\n  mutate(nb = st_contiguity(geometry),\n         wt = st_weights(nb,\n                         style = \"W\"),\n         .before = 1)\n\n\n\nComputing Global Moran’s I\n\nmoranI &lt;- global_moran(wm_q$GDPPC,\n                       wm_q$nb,\n                       wm_q$wt)\nglimpse(moranI)\n\nList of 2\n $ I: num 0.301\n $ K: num 7.64\n\n\n\n\nPerforming Global Moran’s I permutation test\n\nset.seed(1234)\nglobal_moran_perm(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt,\n                  nsim = 99)\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.30075, observed rank = 100, p-value &lt; 2.2e-16\nalternative hypothesis: two.sided"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#setup",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#setup",
    "title": "Take-Home Exercise 2",
    "section": "2.0 Setup",
    "text": "2.0 Setup\n\npacman::p_load(sf, spdep, sfdep, tmap, tidyverse, smoothr, lubridate, nngeo)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#data-wrangling",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#data-wrangling",
    "title": "Take-Home Exercise 2",
    "section": "3.0 Data Wrangling",
    "text": "3.0 Data Wrangling\n\ntn &lt;- st_read(dsn=\"data/geospatial\",\n              layer=\"TAINAN_VILLAGE\")\n\nReading layer `TAINAN_VILLAGE' from data source \n  `C:\\chesterchia\\IS415-GAA\\Take-home_Ex\\Take-home_Ex02\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 649 features and 10 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 120.0269 ymin: 22.88751 xmax: 120.6563 ymax: 23.41374\nGeodetic CRS:  TWD97\n\n\n\ndd &lt;- read_csv(\"data/aspatial/Dengue_Daily.csv\")\n\n\ndd &lt;- dd[, c(1, 10, 11)]\nnames(dd)\n\n[1] \"發病日\"            \"最小統計區中心點X\" \"最小統計區中心點Y\"\n\n\n\nnames(dd) &lt;- c(\"Onset\", \"X\", \"Y\")\nnames(dd)\n\n[1] \"Onset\" \"X\"     \"Y\"    \n\n\n\noptions(digits = 15)\ndd[, c(2, 3)] &lt;- lapply(dd[, c(2, 3)], as.numeric)\nhead(dd)\n\n# A tibble: 6 × 3\n  Onset          X     Y\n  &lt;date&gt;     &lt;dbl&gt; &lt;dbl&gt;\n1 1998-01-02  121.  22.5\n2 1998-01-03  120.  22.5\n3 1998-01-13  122.  24.7\n4 1998-01-15  120.  22.6\n5 1998-01-20  122.  24.7\n6 1998-01-22   NA   NA  \n\n\n\nsum(apply(dd, 1, function(x) any(is.na(x))))\n\n[1] 780\n\n\n\ndd &lt;- na.omit(dd)\nsum(apply(dd, 1, function(x) any(is.na(x))))\n\n[1] 0\n\n\n\nhist(dd$Onset, breaks = \"days\", xlab = \"Date\", ylab = \"Frequency\", main = \"Histogram of Date Ranges\")\n\n\n\n\n\nst_crs(tn)\n\nCoordinate Reference System:\n  User input: TWD97 \n  wkt:\nGEOGCRS[\"TWD97\",\n    DATUM[\"Taiwan Datum 1997\",\n        ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"Taiwan, Republic of China - onshore and offshore - Taiwan Island, Penghu (Pescadores) Islands.\"],\n        BBOX[17.36,114.32,26.96,123.61]],\n    ID[\"EPSG\",3824]]\n\n\n\ndd_sf &lt;- st_as_sf(dd, coords = c(\"X\", \"Y\"),\n                      crs = 3824)\nst_crs(dd_sf)\n\nCoordinate Reference System:\n  User input: EPSG:3824 \n  wkt:\nGEOGCRS[\"TWD97\",\n    DATUM[\"Taiwan Datum 1997\",\n        ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"Taiwan, Republic of China - onshore and offshore - Taiwan Island, Penghu (Pescadores) Islands.\"],\n        BBOX[17.36,114.32,26.96,123.61]],\n    ID[\"EPSG\",3824]]\n\n\n\nhead(dd_sf)\n\nSimple feature collection with 6 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 120.338158907 ymin: 22.46420665 xmax: 121.798235373 ymax: 24.982467229\nGeodetic CRS:  TWD97\n# A tibble: 6 × 2\n  Onset                          geometry\n  &lt;date&gt;                      &lt;POINT [°]&gt;\n1 1998-01-02  (120.505898941 22.46420665)\n2 1998-01-03  (120.45365746 22.466338948)\n3 1998-01-13 (121.751433765 24.749214667)\n4 1998-01-15   (120.338158907 22.6303167)\n5 1998-01-20 (121.798235373 24.684507639)\n6 1998-01-23 (121.547480075 24.982467229)\n\n\n\ntnsz &lt;- tn[tn$TOWNID %in% c(\"D01\", \"D02\", \"D04\", \"D06\", \"D07\", \"D08\", \"D32\", \"D39\"), ] %&gt;% \n  subset(select = -NOTE)\n\n\nhead(tnsz)\n\nSimple feature collection with 6 features and 9 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 120.093638 ymin: 22.9155962890001 xmax: 120.258510056 ymax: 23.0882695690001\nGeodetic CRS:  TWD97\n      VILLCODE COUNTYNAME TOWNNAME VILLNAME       VILLENG COUNTYID COUNTYCODE\n2  67000350032     臺南市   安南區   青草里  Qingcao Vil.        D      67000\n18 67000270011     臺南市   仁德區   保安里   Bao'an Vil.        D      67000\n66 67000370005     臺南市   中西區   赤嵌里  Chihkan Vil.        D      67000\n67 67000330004     臺南市     南區   大成里  Dacheng Vil.        D      67000\n68 67000350028     臺南市   安南區   城北里 Chengbei Vil.        D      67000\n69 67000350030     臺南市   安南區   城南里 Chengnan Vil.        D      67000\n   TOWNID TOWNCODE                       geometry\n2     D06 67000350 POLYGON ((120.117587175 23....\n18    D32 67000270 POLYGON ((120.230434632 22....\n66    D08 67000370 POLYGON ((120.201249051 22....\n67    D02 67000330 POLYGON ((120.198548305 22....\n68    D06 67000350 POLYGON ((120.129195464 23....\n69    D06 67000350 POLYGON ((120.124599602 23....\n\n\n\nplot(tnsz)\n\n\n\n\n\ntnszu &lt;- st_union(tnsz)\nplot(tnszu)\n\n\n\n\n\ntnszuh &lt;- st_remove_holes(tnszu)\nplot(tnszuh)\n\n\n\n\n\ndiff_tnsz &lt;- st_difference(tnszuh, tnszu)\nplot(diff_tnsz)\n\n\n\n\n\nhole &lt;- st_intersection(dd_sf, diff_tnsz)\nhead(hole)\n\nSimple feature collection with 0 features and 1 field\nBounding box:  xmin: NA ymin: NA xmax: NA ymax: NA\nGeodetic CRS:  TWD97\n# A tibble: 0 × 2\n# ℹ 2 variables: Onset &lt;date&gt;, geometry &lt;GEOMETRY [°]&gt;"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/data/geospatial/TAINAN_VILLAGE.html",
    "href": "Take-home_Ex/Take-home_Ex02/data/geospatial/TAINAN_VILLAGE.html",
    "title": "IS415-GAA",
    "section": "",
    "text": "&lt;!DOCTYPE qgis PUBLIC ‘http://mrcc.com/qgis.dtd’ ‘SYSTEM’&gt;     dataset\n\n\n       GEOGCRS[“TWD97”,DATUM[“Taiwan Datum 1997”,ELLIPSOID[“GRS 1980”,6378137,298.257222101,LENGTHUNIT[“metre”,1]]],PRIMEM[“Greenwich”,0,ANGLEUNIT[“degree”,0.0174532925199433]],CS[ellipsoidal,2],AXIS[“geodetic latitude (Lat)”,north,ORDER[1],ANGLEUNIT[“degree”,0.0174532925199433]],AXIS[“geodetic longitude (Lon)”,east,ORDER[2],ANGLEUNIT[“degree”,0.0174532925199433]],USAGE[SCOPE[“Horizontal component of 3D system.”],AREA[“Taiwan, Republic of China - onshore and offshore - Taiwan Island, Penghu (Pescadores) Islands.”],BBOX[17.36,114.32,26.96,123.61]],ID[“EPSG”,3824]] +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs 27230 3824 EPSG:3824 TWD97 longlat EPSG:7019 true"
  }
]